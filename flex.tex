\documentclass[openany,oneside]{book}
\title{GNU Flex Manual}
\author{edited by Richard Dong}
\date{Nov 2014}
\begin{document}

\maketitle

\frontmatter

\chapter{flex}


This manual describes \verb`flex` , a tool for generating programs that
perform pattern-matching on text.  The manual includes both tutorial and
reference sections.

This edition ofdocuments \verb`flex` version
2.5.37. It was last updated on 22 July 2012.

This manual was written by Vern Paxson, Will Estes and John Millaway.

\tableofcontents

\chapter{Copyright}


The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright © 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2012
The Flex Project.

Copyright © 1990, 1997 The Regents of the University of California. 
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
\begin{enumerate}
\item Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
\end{enumerate}


Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED “AS IS” AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
\chapter{Reporting Bugs}

\mainmatter

If you find a bug in \verb`flex` , please report it using
the SourceForge Bug Tracking facilities which can be found onflex's SourceForge Page.
\chapter{Introduction}


 \verb`flex` is a tool for generating.  A scanner is a
program which recognizes lexical patterns in text.  The \verb`flex` program reads the given input files, or its standard input if no file
names are given, for a description of a scanner to generate.  The
description is in the form of pairs of regular expressions and C code,
called. \verb`flex` generates as output a C source file,by default, which defines a routine \verb`yylex()` . 
This file can be compiled and linked with the flex runtime library to
produce an executable.  When the executable is run, it analyzes its
input for occurrences of the regular expressions.  Whenever it finds
one, it executes the corresponding C code.
\chapter{Some Simple Examples}


First some simple examples to get the flavor of how one uses \verb`flex` .

The following \verb`flex` input specifies a scanner which, when it
encounters the string ‘\verb`username`’ will replace it with the user's
login name:
\begin{verbatim}
%%
         username    printf( "%s", getlogin() );
\end{verbatim}


By default, any text not matched by a \verb`flex` scanner is copied to
the output, so the net effect of this scanner is to copy its input file
to its output with each occurrence of ‘\verb`username`’ expanded.  In this
input, there is just one rule.  ‘\verb`username`’ is theand
the ‘\verb`printf`’ is the.  The ‘\verb`%`’ symbol marks the
beginning of the rules.

Here's another simple example:


\begin{verbatim}
int num_lines = 0, num_chars = 0;
     
         %%
         \n      ++num_lines; ++num_chars;
         .       ++num_chars;
     
         %%
     
         int main()
                 {
                 yylex();
                 printf( "# of lines = %d, # of chars = %d\n",
                         num_lines, num_chars );
                 }
\end{verbatim}


This scanner counts the number of characters and the number of lines in
its input. It produces no output other than the final report on the
character and line counts.  The first line declares two globals, \verb`num_lines` and \verb`num_chars` , which are accessible both inside \verb`yylex()` and in the \verb`main()` routine declared after the
second ‘\verb`%`’.  There are two rules, one which matches a newline
(‘\verb`\n`’) and increments both the line count and the character count,
and one which matches any character other than a newline (indicated by
the ‘\verb`.`’ regular expression).

A somewhat more complicated example:


\begin{verbatim}
/* scanner for a toy Pascal-like language */
     
         %{
         /* need this for the call to atof() below */
         #include <math.h>
         %}
     
         DIGIT    [0-9]
         ID       [a-z][a-z0-9]*
     
         %%
     
         {DIGIT}+    {
                     printf( "An integer: %s (%d)\n", yytext,
                             atoi( yytext ) );
                     }
     
         {DIGIT}+"."{DIGIT}*        {
                     printf( "A float: %s (%g)\n", yytext,
                             atof( yytext ) );
                     }
     
         if|then|begin|end|procedure|function        {
                     printf( "A keyword: %s\n", yytext );
                     }
     
         {ID}        printf( "An identifier: %s\n", yytext );
     
         "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );
     
         "{"[\^{}}\n]*"}"     /* eat up one-line comments */
     
         [ \t\n]+          /* eat up whitespace */
     
         .           printf( "Unrecognized character: %s\n", yytext );
     
         %%
     
         int main( int argc, char **argv )
             {
             ++argv, --argc;  /* skip over program name */
             if ( argc > 0 )
                     yyin = fopen( argv[0], "r" );
             else
                     yyin = stdin;
     
             yylex();
             }
\end{verbatim}


This is the beginnings of a simple scanner for a language like Pascal. 
It identifies different types ofand reports on what it has
seen.

The details of this example will be explained in the following
sections.
\chapter{Format of the Input File}


The \verb`flex` input file consists of three sections, separated by a
line containing only ‘\verb`%%`’.


\begin{verbatim}
definitions
         %%
         rules
         %%
         user code
\end{verbatim}

\begin{itemize}
\item Definitions Section
\item Rules Section
\item User Code Section
\item Comments in the Input
\end{itemize}

\section{Format of the Definitions Section}


Thecontains declarations of simpledefinitions to simplify the scanner specification, and declarations of, which are explained in a later section.

Name definitions have the form:
\begin{verbatim}
name definition
\end{verbatim}


The ‘\verb`name`’ is a word beginning with a letter or an underscore
(‘\verb`_`’) followed by zero or more letters, digits, ‘\verb`_`’, or
‘\verb`-`’ (dash).  The definition is taken to begin at the first
non-whitespace character following the name and continuing to the end of
the line.  The definition can subsequently be referred to using
‘\verb`{name}`’, which will expand to ‘\verb`(definition)`’.  For example,


\begin{verbatim}
DIGIT    [0-9]
         ID       [a-z][a-z0-9]*
\end{verbatim}


Defines ‘\verb`DIGIT`’ to be a regular expression which matches a single
digit, and ‘\verb`ID`’ to be a regular expression which matches a letter
followed by zero-or-more letters-or-digits.  A subsequent reference to


\begin{verbatim}
{DIGIT}+"."{DIGIT}*
\end{verbatim}


is identical to
\begin{verbatim}
([0-9])+"."([0-9])*
\end{verbatim}


and matches one-or-more digits followed by a ‘\verb`.`’ followed by
zero-or-more digits.

An unindented comment (i.e., a line
beginning with ‘\verb`/*`’) is copied verbatim to the output up
to the next ‘\verb`*/`’.

Anytext or text enclosed in ‘\verb`%{`’ and ‘\verb`%}`’
is also copied verbatim to the output (with the \%{}\{{} and \%{}\}{} symbols
removed).  The \%{}\{{} and \%{}\}{} symbols must appear unindented on lines by
themselves.

A \verb`%top` block is similar to a ‘\verb`%{`’ ... ‘\verb`%}`’ block, except
that the code in a \verb`%top` block is relocated to theof the
generated file, before any flex definitions. 
The \verb`%top` block is useful when you want certain preprocessor macros to be
defined or certain files to be included before the generated code. 
The single characters, ‘\verb`{`’  and ‘\verb`}`’ are used to delimit the \verb`%top` block, as show in the example below:
\begin{verbatim}
%top{
             /* This code goes at the "top" of the generated file. */
             #include <stdint.h>
             #include <inttypes.h>
         }
\end{verbatim}


Multiple \verb`%top` blocks are allowed, and their order is preserved.

1Actually, \verb`yyIN_HEADER` is defined before the ‘\verb`%top`’ block.
\section{Format of the Rules Section}


Thesection of the \verb`flex` input contains a series of
rules of the form:
\begin{verbatim}
pattern   action
\end{verbatim}


where the pattern must be unindented and the action must begin
on the same line. 
SeePatterns, for a further description of patterns and actions.

In the rules section, any indented or \%{}\{{} \%{}\}{} enclosed text appearing
before the first rule may be used to declare variables which are local
to the scanning routine and (after the declarations) code which is to be
executed whenever the scanning routine is entered.  Other indented or
\%{}\{{} \%{}\}{} text in the rule section is still copied to the output, but its
meaning is not well-defined and it may well cause compile-time errors
(this feature is present forcompliance. SeeLex and Posix, for other such features).

Anytext or text enclosed in ‘\verb`%{`’ and ‘\verb`%}`’
is copied verbatim to the output (with the \%{}\{{} and \%{}\}{} symbols removed). 
The \%{}\{{} and \%{}\}{} symbols must appear unindented on lines by themselves.
\section{Format of the User Code Section}


The user code section is simply copied toverbatim.  It
is used for companion routines which call or are called by the scanner. 
The presence of this section is optional; if it is missing, the second
‘\verb`%`’ in the input file may be skipped, too.
\section{Comments in the Input}


Flex supports C-style comments, that is, anything between ‘\verb`/*`’ and
‘\verb`*/`’ is
considered a comment. Whenever flex encounters a comment, it copies the
entire comment verbatim to the generated source code. Comments may
appear just about anywhere, but with the following exceptions:
\begin{itemize}
\item Comments may not appear in the Rules Section wherever flex is expecting
a regular expression. This means comments may not appear at the
beginning of a line, or immediately following a list of scanner states.
\item Comments may not appear on an ‘\verb`%option`’ line in the Definitions
Section.
\end{itemize}


If you want to follow a simple rule, then always begin a comment on a
new line, with one or more whitespace characters before the initial
‘\verb`/*`’).  This rule will work anywhere in the input file.

All the comments in the following example are valid:


\begin{verbatim}
%{
     /* code block */
     %}
     
     /* Definitions Section */
     %x STATE_X
     
     %%
         /* Rules Section */
     ruleA   /* after regex */ { /* code block */ } /* after code block */
             /* Rules Section (indented) */
     <STATE_X>{
     ruleC   ECHO;
     ruleD   ECHO;
     %{
     /* code block */
     %}
     }
     %%
     /* User Code Section */
\end{verbatim}

\chapter{Patterns}


The patterns in the input (seeRules Section) are written using an
extended set of regular expressions.  These are:

\verb`x`match the character 'x'\verb`.`any character (byte) except newline

\verb`[xyz]`a; in this case, the pattern
matches either an 'x', a 'y', or a 'z'

\verb`[abj-oZ]`a "character class" with a range in it; matches
an 'a', a 'b', any letter from 'j' through 'o',
or a 'Z'

\verb`[^A-Z]`a "negated character class", i.e., any character
but those in the class.  In this case, any
character EXCEPT an uppercase letter.\verb`[^A-Z\n]`any character EXCEPT an uppercase letter or
a newline\verb`[a-z]{-}[aeiou]`the lowercase consonants\verb`r*`zero or more r's, where r is any regular expression\verb`r+`one or more r's\verb`r?`zero or one r's (that is, “an optional r”)

\verb`r{2,5}`anywhere from two to five r's\verb`r{2,}`two or more r's\verb`r{4}`exactly 4 r's

\verb`{name}`the expansion of the ‘\verb`name`’ definition
(seeFormat).

\verb`"[xyz]\"foo"`the literal string: ‘\verb`[xyz]"foo`’

\verb`\X`if X is ‘\verb`a`’, ‘\verb`b`’, ‘\verb`f`’, ‘\verb`n`’, ‘\verb`r`’, ‘\verb`t`’, or
‘\verb`v`’, then the ANSI-C interpretation of ‘\verb`\x`’.  Otherwise, a
literal ‘\verb`X`’ (used to escape operators such as ‘\verb`*`’)

\verb`\0`a NUL character (ASCII code 0)

\verb`\123`the character with octal value 123\verb`\x2a`the character with hexadecimal value 2a\verb`(r)`match an ‘\verb`r`’; parentheses are used to override precedence (see below)\verb`(?r-s:pattern)`apply option ‘\verb`r`’ and omit option ‘\verb`s`’ while interpreting pattern. 
Options may be zero or more of the characters ‘\verb`i`’, ‘\verb`s`’, or ‘\verb`x`’.

‘\verb`i`’ means case-insensitive. ‘\verb`-i`’ means case-sensitive.

‘\verb`s`’ alters the meaning of the ‘\verb`.`’ syntax to match any single byte whatsoever. 
‘\verb`-s`’ alters the meaning of ‘\verb`.`’ to match any byte except ‘\verb`\n`’.

‘\verb`x`’ ignores comments and whitespace in patterns. Whitespace is ignored unless
it is backslash-escaped, contained within ‘\verb`""`’s, or appears inside a
character class.

The following are all valid:
\begin{verbatim}
(?:foo)         same as  (foo)
     (?i:ab7)        same as  ([aA][bB]7)
     (?-i:ab)        same as  (ab)
     (?s:.)          same as  [\x00-\xFF]
     (?-s:.)         same as  [^\n]
     (?ix-s: a . b)  same as  ([Aa][^\n][bB])
     (?x:a  b)       same as  ("ab")
     (?x:a\ b)       same as  ("a b")
     (?x:a" "b)      same as  ("a b")
     (?x:a[ ]b)      same as  ("a b")
     (?x:a
         /* comment */
         b
         c)          same as  (abc)
\end{verbatim}
\verb`(?# comment )`omit everything within ‘\verb`()`’. The first ‘\verb`)`’
character encountered ends the pattern. It is not possible to for the comment
to contain a ‘\verb`)`’ character. The comment may span lines.

\verb`rs`the regular expression ‘\verb`r`’ followed by the regular expression ‘\verb`s`’; called\verb`r|s`either an ‘\verb`r`’ or an ‘\verb`s`’

\verb`r/s`an ‘\verb`r`’ but only if it is followed by an ‘\verb`s`’.  The text matched by ‘\verb`s`’ is
included when determining whether this rule is the longest match, but is
then returned to the input before the action is executed.  So the action
only sees the text matched by ‘\verb`r`’.  This type of pattern is called.  (There are some combinations of ‘\verb`r/s`’ that flex
cannot match correctly. SeeLimitations, regarding dangerous trailing
context.)

\verb`^r`an ‘\verb`r`’, but only at the beginning of a line (i.e.,
when just starting to scan, or right after a
newline has been scanned).

\verb`r$`an ‘\verb`r`’, but only at the end of a line (i.e., just before a
newline).  Equivalent to ‘\verb`r/\n`’.

Note that \verb`flex` 's notion of “newline” is exactly
whatever the C compiler used to compile \verb`flex` interprets ‘\verb`\n`’ as; in particular, on some DOS
systems you must either filter out ‘\verb`\r`’s in the
input yourself, or explicitly use ‘\verb`r/\r\n`’ for ‘\verb`r$`’.

\verb`<s>r`an ‘\verb`r`’, but only in start condition \verb`s` (seeStart Conditionsfor discussion of start conditions).\verb`<s1,s2,s3>r`same, but in any of start conditions \verb`s1` , \verb`s2` , or \verb`s3` .\verb`<*>r`an ‘\verb`r`’ in any start condition, even an exclusive one.

\verb`<<EOF>>`an end-of-file.\verb`<s1,s2><<EOF>>`an end-of-file when in start condition \verb`s1` or \verb`s2` 

Note that inside of a character class, all regular expression operators
lose their special meaning except escape (‘\verb`\`’) and the character class
operators, ‘\verb`-`’, ‘\verb`]]`’, and, at the beginning of the class, ‘\verb`^`’.

The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the bottom. 
Those grouped together have equal precedence (see special note on the
precedence of the repeat operator, ‘\verb`{}`’, under the documentation
for the ‘\verb`--posix`’ POSIX compliance option).  For example,


\begin{verbatim}
foo|bar*
\end{verbatim}


is the same as
\begin{verbatim}
(foo)|(ba(r*))
\end{verbatim}


since the ‘\verb`*`’ operator has higher precedence than concatenation,
and concatenation higher than alternation (‘\verb`|`’).  This pattern
therefore matchesthe string ‘\verb`foo`’the
string ‘\verb`ba`’ followed by zero-or-more ‘\verb`r`’'s.  To match
‘\verb`foo`’ or zero-or-more repetitions of the string ‘\verb`bar`’, use:
\begin{verbatim}
foo|(bar)*
\end{verbatim}


And to match a sequence of zero or more repetitions of ‘\verb`foo`’ and
‘\verb`bar`’:


\begin{verbatim}
(foo|bar)*
\end{verbatim}


In addition to characters and ranges of characters, character classes
can also contain.  These are
expressions enclosed inside ‘\verb`[`’: and ‘\verb`:]`’ delimiters (which
themselves must appear between the ‘\verb`[`’ and ‘\verb`]`’ of the
character class. Other elements may occur inside the character class,
too).  The valid expressions are:


\begin{verbatim}
[:alnum:] [:alpha:] [:blank:]
         [:cntrl:] [:digit:] [:graph:]
         [:lower:] [:print:] [:punct:]
         [:space:] [:upper:] [:xdigit:]
\end{verbatim}


These expressions all designate a set of characters equivalent to the
corresponding standard C \verb`isXXX` function.  For example,
‘\verb`[:alnum:]`’ designates those characters for which \verb`isalnum()` returns true - i.e., any alphabetic or numeric character.  Some systems
don't provide \verb`isblank()` , so flex defines ‘\verb`[:blank:]`’ as a
blank or a tab.

For example, the following character classes are all equivalent:


\begin{verbatim}
[[:alnum:]]
         [[:alpha:][:digit:]]
         [[:alpha:][0-9]]
         [a-zA-Z0-9]
\end{verbatim}


A word of caution. Character classes are expanded immediately when seen in the \verb`flex` input. 
This means the character classes are sensitive to the locale in which \verb`flex` is executed, and the resulting scanner will not be sensitive to the runtime locale. 
This may or may not be desirable.
\begin{itemize}
\item If your scanner is case-insensitive (the ‘\verb`-i`’ flag), then
‘\verb`[:upper:]`’ and ‘\verb`[:lower:]`’ are equivalent to
‘\verb`[:alpha:]`’.

\item Character classes with ranges, such as ‘\verb`[a-Z]`’, should be used with
caution in a case-insensitive scanner if the range spans upper or lowercase
characters. Flex does not know if you want to fold all upper and lowercase
characters together, or if you want the literal numeric range specified (with
no case folding). When in doubt, flex will assume that you meant the literal
numeric range, and will issue a warning. The exception to this rule is a
character range such as ‘\verb`[a-z]`’ or ‘\verb`[S-W]`’ where it is obvious that you
want case-folding to occur. Here are some examples with the ‘\verb`-i`’ flag
enabled:

%\verb`[a-t]`\verb`[a-tA-T]`\verb`[A-T]`\verb`[a-tA-T]`\verb`[A-t]`\verb`[A-Z\[\\\]_`a-t]`\verb`[a-tA-T]`\verb`[_-{]`\verb`[_`a-z{]`\verb`[_`a-zA-Z{]`\verb`[@-C]`\verb`[@ABC]`\verb`[@A-Z\[\\\]_`abc]`


\item A negated character class such as the example ‘\verb`[^A-Z]`’ abovematch a newline unless ‘\verb`\n`’ (or an equivalent escape
sequence) is one of the characters explicitly present in the negated
character class (e.g., ‘\verb`[^A-Z\n]`’).  This is unlike how many other
regular expression tools treat negated character classes, but
unfortunately the inconsistency is historically entrenched.  Matching
newlines means that a pattern like ‘\verb`[^"]*`’ can match the entire
input unless there's another quote in the input.


Flex allows negation of character class expressions by prepending ‘\verb`^`’ to
the POSIX character class name.
\begin{verbatim}
[:^alnum:] [:^alpha:] [:^blank:]
              [:^cntrl:] [:^digit:] [:^graph:]
              [:^lower:] [:^print:] [:^punct:]
              [:^space:] [:^upper:] [:^xdigit:]
\end{verbatim}


Flex will issue a warning if the expressions ‘\verb`[:^upper:]`’ and
‘\verb`[:^lower:]`’ appear in a case-insensitive scanner, since their meaning is
unclear. The current behavior is to skip them entirely, but this may change
without notice in future revisions of flex.
\item The ‘\verb`{-}`’ operator computes the difference of two character classes. For
example, ‘\verb`[a-c]{-}[b-z]`’ represents all the characters in the class
‘\verb`[a-c]`’ that are not in the class ‘\verb`[b-z]`’ (which in this case, is
just the single character ‘\verb`a`’). The ‘\verb`{-}`’ operator is left
associative, so ‘\verb`[abc]{-}[b]{-}[c]`’ is the same as ‘\verb`[a]`’. Be careful
not to accidentally create an empty set, which will never match.
\item The ‘\verb`{+}`’ operator computes the union of two character classes. For
example, ‘\verb`[a-z]{+}[0-9]`’ is the same as ‘\verb`[a-z0-9]`’. This operator
is useful when preceded by the result of a difference operation, as in,
‘\verb`[[:alpha:]]{-}[[:lower:]]{+}[q]`’, which is equivalent to
‘\verb`[A-Zq]`’ in the "C" locale.


\item A rule can have at most one instance of trailing context (the ‘\verb`/`’ operator
or the ‘\verb`$`’ operator).  The start condition, ‘\verb`^`’, and ‘\verb`<<EOF>>`’ patterns
can only occur at the beginning of a pattern, and, as well as with ‘\verb`/`’ and ‘\verb`$`’,
cannot be grouped inside parentheses.  A ‘\verb`^`’ which does not occur at
the beginning of a rule or a ‘\verb`$`’ which does not occur at the end of
a rule loses its special properties and is treated as a normal character.
\item The following are invalid:


\begin{verbatim}
foo/bar$
              <sc1>foo<sc2>bar
\end{verbatim}


Note that the first of these can be written ‘\verb`foo/bar\n`’.
\item The following will result in ‘\verb`$`’ or ‘\verb`^`’ being treated as a normal character:


\begin{verbatim}
foo|(bar$)
              foo|^bar
\end{verbatim}


If the desired meaning is a ‘\verb`foo`’ or a
‘\verb`bar`’-followed-by-a-newline, the following could be used (the
special \verb`|` action is explained below, seeActions):


\begin{verbatim}
foo      |
              bar$     /* action goes here */
\end{verbatim}


A similar trick will work for matching a ‘\verb`foo`’ or a
‘\verb`bar`’-at-the-beginning-of-a-line.
\end{itemize}

\chapter{How the Input Is Matched}


When the generated scanner is run, it analyzes its input looking for
strings which match any of its patterns.  If it finds more than one
match, it takes the one matching the most text (for trailing context
rules, this includes the length of the trailing part, even though it
will then be returned to the input).  If it finds two or more matches of
the same length, the rule listed first in the \verb`flex` input file is
chosen.

Once the match is determined, the text corresponding to the match
(called the) is made available in the global character
pointer \verb`yytext` , and its length in the global integer \verb`yyleng` .  Thecorresponding to the matched pattern is
then executed (seeActions), and then the remaining input is scanned
for another match.

If no match is found, then theis executed: the next
character in the input is considered matched and copied to the standard
output.  Thus, the simplest valid \verb`flex` input is:


\begin{verbatim}
%%
\end{verbatim}


which generates a scanner that simply copies its input (one character at
a time) to its output.

Note that \verb`yytext` can be defined in two different ways: either as
a characteror as a character. You can
control which definition \verb`flex` uses by including one of the
special directives \verb`%pointer` or \verb`%array` in the first
(definitions) section of your flex input.  The default is \verb`%pointer` , unless you use the ‘\verb`-l`’ lex compatibility option,
in which case \verb`yytext` will be an array.  The advantage of using \verb`%pointer` is substantially faster scanning and no buffer overflow
when matching very large tokens (unless you run out of dynamic memory). 
The disadvantage is that you are restricted in how your actions can
modify \verb`yytext` (seeActions), and calls to the \verb`unput()` function destroys the present contents of \verb`yytext` , which can be a
considerable porting headache when moving between different \verb`lex` versions.

The advantage of \verb`%array` is that you can then modify \verb`yytext` to your heart's content, and calls to \verb`unput()` do not destroy \verb`yytext` (seeActions).  Furthermore, existing \verb`lex` programs sometimes access \verb`yytext` externally using declarations of
the form:
\begin{verbatim}
extern char yytext[];
\end{verbatim}


This definition is erroneous when used with \verb`%pointer` , but correct
for \verb`%array` .

The \verb`%array` declaration defines \verb`yytext` to be an array of \verb`YYLMAX` characters, which defaults to a fairly large value.  You
can change the size by simply \#{}define'ing \verb`YYLMAX` to a different
value in the first section of your \verb`flex` input.  As mentioned
above, with \verb`%pointer` yytext grows dynamically to accommodate
large tokens.  While this means your \verb`%pointer` scanner can
accommodate very large tokens (such as matching entire blocks of
comments), bear in mind that each time the scanner must resize \verb`yytext` it also must rescan the entire token from the beginning,
so matching such tokens can prove slow. \verb`yytext` presently doesdynamically grow if a call to \verb`unput()` results in too
much text being pushed back; instead, a run-time error results.

Also note that you cannot use \verb`%array` with C++ scanner classes
(seeCxx).
\chapter{Actions}


Each pattern in a rule has a corresponding, which can be
any arbitrary C statement.  The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action.  If the
action is empty, then when the pattern is matched the input token is
simply discarded.  For example, here is the specification for a program
which deletes all occurrences of ‘\verb`zap me`’ from its input:


\begin{verbatim}
%%
         "zap me"
\end{verbatim}


This example will copy all other characters in the input to the output
since they will be matched by the default rule.

Here is a program which compresses multiple blanks and tabs down to a
single blank, and throws away whitespace found at the end of a line:


\begin{verbatim}
%%
         [ \t]+        putchar( ' ' );
         [ \t]+$       /* ignore this token */
\end{verbatim}


If the action contains a ‘\verb`{`’, then the action spans till the
balancing ‘\verb`}`’ is found, and the action may cross multiple lines. \verb`flex` knows about C strings and comments and won't be fooled by
braces found within them, but also allows actions to begin with
‘\verb`%{`’ and will consider the action to be all the text up to the
next ‘\verb`%}`’ (regardless of ordinary braces inside the action).

An action consisting solely of a vertical bar (‘\verb`|`’) means “same as the
action for the next rule”.  See below for an illustration.

Actions can include arbitrary C code, including \verb`return` statements
to return a value to whatever routine called \verb`yylex()` .  Each time \verb`yylex()` is called it continues processing tokens from where it
last left off until it either reaches the end of the file or executes a
return.

Actions are free to modify \verb`yytext` except for lengthening it
(adding characters to its end–these will overwrite later characters in
the input stream).  This however does not apply when using \verb`%array` (seeMatching). In that case, \verb`yytext` may be freely modified
in any way.

Actions are free to modify \verb`yyleng` except they should not do so if
the action also includes use of \verb`yymore()` (see below).

There are a number of special directives which can be included within an
action: \verb`ECHO` copies yytext to the scanner's output. \verb`BEGIN` followed by the name of a start condition places the scanner in the
corresponding start condition (see below). \verb`REJECT` directs the scanner to proceed on to the “second best” rule which
matched the input (or a prefix of the input).  The rule is chosen as
described above inMatching, and \verb`yytext` and \verb`yyleng` set up appropriately.  It may either be one which matched as much text
as the originally chosen rule but came later in the \verb`flex` input
file, or one which matched less text.  For example, the following will
both count the words in the input and call the routine \verb`special()` whenever ‘\verb`frob`’ is seen:
\begin{verbatim}
int word_count = 0;
              %%
          
              frob        special(); REJECT;
              [^ \t\n]+   ++word_count;
\end{verbatim}


Without the \verb`REJECT` , any occurrences of ‘\verb`frob`’ in the input
would not be counted as words, since the scanner normally executes only
one action per token.  Multiple uses of \verb`REJECT` are allowed, each
one finding the next best choice to the currently active rule.  For
example, when the following scanner scans the token ‘\verb`abcd`’, it will
write ‘\verb`abcdabcaba`’ to the output:


\begin{verbatim}
%%
              a        |
              ab       |
              abc      |
              abcd     ECHO; REJECT;
              .|\n     /* eat up any unmatched character */
\end{verbatim}


The first three rules share the fourth's action since they use the
special ‘\verb`|`’ action.

 \verb`REJECT` is a particularly expensive feature in terms of scanner
performance; if it is used inof the scanner's actions it
will slow downof the scanner's matching.  Furthermore, \verb`REJECT` cannot be used with the ‘\verb`-Cf`’ or ‘\verb`-CF`’ options
(seeScanner Options).

Note also that unlike the other special actions, \verb`REJECT` is a.  Code immediately following it in the action willbe executed. \verb`yymore()` tells the scanner that the next time it matches a rule, the
corresponding token should beonto the current value of \verb`yytext` rather than replacing it.  For example, given the input
‘\verb`mega-kludge`’ the following will write ‘\verb`mega-mega-kludge`’ to
the output:


\begin{verbatim}
%%
              mega-    ECHO; yymore();
              kludge   ECHO;
\end{verbatim}


First ‘\verb`mega-`’ is matched and echoed to the output.  Then ‘\verb`kludge`’
is matched, but the previous ‘\verb`mega-`’ is still hanging around at the
beginning of \verb`yytext` so the \verb`ECHO` for the ‘\verb`kludge`’ rule will actually write ‘\verb`mega-kludge`’.

Two notes regarding use of \verb`yymore()` .  First, \verb`yymore()` depends on the value of \verb`yyleng` correctly reflecting the size of
the current token, so you must not modify \verb`yyleng` if you are using \verb`yymore()` .  Second, the presence of \verb`yymore()` in the
scanner's action entails a minor performance penalty in the scanner's
matching speed.

 \verb`yyless(n)` returns all but the first \verb`n` characters of the
current token back to the input stream, where they will be rescanned
when the scanner looks for the next match. \verb`yytext` and \verb`yyleng` are adjusted appropriately (e.g., \verb`yyleng` will now
be equal to \verb`n` ).  For example, on the input ‘\verb`foobar`’ the
following will write out ‘\verb`foobarbar`’:


\begin{verbatim}
%%
         foobar    ECHO; yyless(3);
         [a-z]+    ECHO;
\end{verbatim}


An argument of 0 to \verb`yyless()` will cause the entire current input
string to be scanned again.  Unless you've changed how the scanner will
subsequently process its input (using \verb`BEGIN` , for example), this
will result in an endless loop.

Note that \verb`yyless()` is a macro and can only be used in the flex
input file, not from other source files.

 \verb`unput(c)` puts the character \verb`c` back onto the input stream. 
It will be the next character scanned.  The following action will take
the current token and cause it to be rescanned enclosed in parentheses.


\begin{verbatim}
{
         int i;
         /* Copy yytext because unput() trashes yytext */
         char *yycopy = strdup( yytext );
         unput( ')' );
         for ( i = yyleng - 1; i >= 0; --i )
             unput( yycopy[i] );
         unput( '(' );
         free( yycopy );
         }
\end{verbatim}


Note that since each \verb`unput()` puts the given character back at theof the input stream, pushing back strings must be done
back-to-front.

An important potential problem when using \verb`unput()` is that if you
are using \verb`%pointer` (the default), a call to \verb`unput()` the contents of \verb`yytext` , starting with its
rightmost character and devouring one character to the left with each
call.  If you need the value of \verb`yytext` preserved after a call to \verb`unput()` (as in the above example), you must either first copy it
elsewhere, or build your scanner using \verb`%array` instead
(seeMatching).

Finally, note that you cannot put back ‘\verb`EOF`’ to attempt to mark the
input stream with an end-of-file.

 \verb`input()` reads the next character from the input stream.  For
example, the following is one way to eat up C comments:


\begin{verbatim}
%%
         "/*"        {
                     register int c;
     
                     for ( ; ; )
                         {
                         while ( (c = input()) != '*' &&
                                 c != EOF )
                             ;    /* eat up text of comment */
     
                         if ( c == '*' )
                             {
                             while ( (c = input()) == '*' )
                                 ;
                             if ( c == '/' )
                                 break;    /* found the end */
                             }
     
                         if ( c == EOF )
                             {
                             error( "EOF in comment" );
                             break;
                             }
                         }
                     }
\end{verbatim}


(Note that if the scanner is compiled using \verb`C++` , then \verb`input()` is instead referred to as, in order to
avoid a name clash with the \verb`C++` stream by the name of \verb`input` .)

 \verb`YY_FLUSH_BUFFER;` flushes the scanner's internal buffer so that
the next time the scanner attempts to match a token, it will first
refill the buffer using \verb`YY_INPUT()` (seeGenerated Scanner). 
This action is a special case of the more general \verb`yy_flush_buffer;` function, described below (seeMultiple Input Buffers)

 \verb`yyterminate()` can be used in lieu of a return statement in an
action.  It terminates the scanner and returns a 0 to the scanner's
caller, indicating “all done”.  By default, \verb`yyterminate()` is
also called when an end-of-file is encountered.  It is a macro and may
be redefined.
\chapter{The Generated Scanner}


The output of \verb`flex` is the file, which contains
the scanning routine \verb`yylex()` , a number of tables used by it for
matching tokens, and a number of auxiliary routines and macros.  By
default, \verb`yylex()` is declared as follows:
\begin{verbatim}
int yylex()
             {
             ... various definitions and the actions in here ...
             }
\end{verbatim}


(If your environment supports function prototypes, then it will be \verb`int yylex( void )` .)  This definition may be changed by defining
the \verb`YY_DECL` macro.  For example, you could use:


\begin{verbatim}
#define YY_DECL float lexscan( a, b ) float a, b;
\end{verbatim}


to give the scanning routine the name \verb`lexscan` , returning a float,
and taking two floats as arguments.  Note that if you give arguments to
the scanning routine using a K\&{}R-style/non-prototyped function
declaration, you must terminate the definition with a semi-colon (;).

 \verb`flex` generates ‘\verb`C99`’ function definitions by
default. However flex does have the ability to generate obsolete, er,
‘\verb`traditional`’, function definitions. This is to support
bootstrapping gcc on old systems.  Unfortunately, traditional
definitions prevent us from using any standard data types smaller than
int (such as short, char, or bool) as function arguments.  For this
reason, future versions of \verb`flex` may generate standard C99 code
only, leaving K\&{}R-style functions to the historians.  Currently, if you
dowant ‘\verb`C99`’ definitions, then you must use \verb`%option noansi-definitions` .

Whenever \verb`yylex()` is called, it scans tokens from the global input
file(which defaults to stdin).  It continues until it
either reaches an end-of-file (at which point it returns the value 0) or
one of its actions executes a \verb`return` statement.

If the scanner reaches an end-of-file, subsequent calls are undefined
unless eitheris pointed at a new input file (in which case
scanning continues from that file), or \verb`yyrestart()` is called. \verb`yyrestart()` takes one argument, a \verb`FILE *` pointer (which
can be NULL, if you've set up \verb`YY_INPUT` to scan from a source other
than \verb`yyin` ), and initializesfor scanning from that
file.  Essentially there is no difference between just assigningto a new input file or using \verb`yyrestart()` to do so;
the latter is available for compatibility with previous versions of \verb`flex` , and because it can be used to switch input files in the
middle of scanning.  It can also be used to throw away the current input
buffer, by calling it with an argument of; but it would be
better to use \verb`YY_FLUSH_BUFFER` (seeActions).  Note that \verb`yyrestart()` doesreset the start condition to \verb`INITIAL` (seeStart Conditions).

If \verb`yylex()` stops scanning due to executing a \verb`return` statement in one of the actions, the scanner may then be called again
and it will resume scanning where it left off.

By default (and for purposes of efficiency), the scanner uses
block-reads rather than simple \verb`getc()` calls to read characters
from.  The nature of how it gets its input can be controlled
by defining the \verb`YY_INPUT` macro.  The calling sequence for \verb`YY_INPUT()` is \verb`YY_INPUT(buf,result,max_size)` .  Its action
is to place up to \verb`max_size` characters in the character array \verb`buf` and return in the integer variable \verb`result` either the
number of characters read or the constant \verb`YY_NULL` (0 on Unix
systems) to indicate ‘\verb`EOF`’.  The default \verb`YY_INPUT` reads from
the global file-pointer.

Here is a sample definition of \verb`YY_INPUT` (in the definitions
section of the input file):
\begin{verbatim}
%{
         #define YY_INPUT(buf,result,max_size) \
             { \
             int c = getchar(); \
             result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
             }
         %}
\end{verbatim}


This definition will change the input processing to occur one character
at a time.

When the scanner receives an end-of-file indication from YY\_{}INPUT, it
then checks the \verb`yywrap()` function.  If \verb`yywrap()` returns
false (zero), then it is assumed that the function has gone ahead and
set upto point to another input file, and scanning
continues.  If it returns true (non-zero), then the scanner terminates,
returning 0 to its caller.  Note that in either case, the start
condition remains unchanged; it doesrevert to \verb`INITIAL` .

If you do not supply your own version of \verb`yywrap()` , then you must
either use \verb`%option noyywrap` (in which case the scanner behaves as
though \verb`yywrap()` returned 1), or you must link with ‘\verb`-lfl`’ to
obtain the default version of the routine, which always returns 1.

For scanning from in-memory buffers (e.g., scanning strings), seeScanning Strings. SeeMultiple Input Buffers.

The scanner writes its \verb`ECHO` output to theglobal
(default,), which may be redefined by the user simply by
assigning it to some other \verb`FILE` pointer.
\chapter{Start Conditions}


 \verb`flex` provides a mechanism for conditionally activating rules. 
Any rule whose pattern is prefixed with ‘\verb`<sc>`’ will only be active
when the scanner is in thenamed \verb`sc` .  For
example,
\begin{verbatim}
<STRING>[^"]*        { /* eat up the string body ... */
                     ...
                     }
\end{verbatim}


will be active only when the scanner is in the \verb`STRING` start
condition, and


\begin{verbatim}
<INITIAL,STRING,QUOTE>\.        { /* handle an escape ... */
                     ...
                     }
\end{verbatim}


will be active only when the current start condition is either \verb`INITIAL` , \verb`STRING` , or \verb`QUOTE` .

Start conditions are declared in the definitions (first) section of the
input using unindented lines beginning with either ‘\verb`%s`’ or
‘\verb`%x`’ followed by a list of names.  The former declaresstart conditions, the latterstart
conditions.  A start condition is activated using the \verb`BEGIN` action.  Until the next \verb`BEGIN` action is executed, rules with the
given start condition will be active and rules with other start
conditions will be inactive.  If the start condition is inclusive, then
rules with no start conditions at all will also be active.  If it is
exclusive, thenrules qualified with the start condition
will be active.  A set of rules contingent on the same exclusive start
condition describe a scanner which is independent of any of the other
rules in the \verb`flex` input.  Because of this, exclusive start
conditions make it easy to specify “mini-scanners” which scan portions
of the input that are syntactically different from the rest (e.g.,
comments).

If the distinction between inclusive and exclusive start conditions
is still a little vague, here's a simple example illustrating the
connection between the two.  The set of rules:


\begin{verbatim}
%s example
         %%
     
         <example>foo   do_something();
     
         bar            something_else();
\end{verbatim}


is equivalent to


\begin{verbatim}
%x example
         %%
     
         <example>foo   do_something();
     
         <INITIAL,example>bar    something_else();
\end{verbatim}


Without the \verb`<INITIAL,example>` qualifier, the \verb`bar` pattern in
the second example wouldn't be active (i.e., couldn't match) when in
start condition \verb`example` .  If we just used \verb`<example>` to
qualify \verb`bar` , though, then it would only be active in \verb`example` and not in \verb`INITIAL` , while in the first example
it's active in both, because in the first example the \verb`example` start condition is an inclusive \verb`(%s)` start condition.

Also note that the special start-condition specifier \verb`<*>` matches every start condition.  Thus, the above example could also
have been written:


\begin{verbatim}
%x example
         %%
     
         <example>foo   do_something();
     
         <*>bar    something_else();
\end{verbatim}


The default rule (to \verb`ECHO` any unmatched character) remains active
in start conditions.  It is equivalent to:


\begin{verbatim}
<*>.|\n     ECHO;
\end{verbatim}


 \verb`BEGIN(0)` returns to the original state where only the rules with
no start conditions are active.  This state can also be referred to as
the start-condition \verb`INITIAL` , so \verb`BEGIN(INITIAL)` is
equivalent to \verb`BEGIN(0)` .  (The parentheses around the start
condition name are not required but are considered good style.)

 \verb`BEGIN` actions can also be given as indented code at the beginning
of the rules section.  For example, the following will cause the scanner
to enter the \verb`SPECIAL` start condition whenever \verb`yylex()` is
called and the global variable \verb`enter_special` is true:


\begin{verbatim}
int enter_special;
     
         %x SPECIAL
         %%
                 if ( enter_special )
                     BEGIN(SPECIAL);
     
         <SPECIAL>blahblahblah
         ...more rules follow...
\end{verbatim}


To illustrate the uses of start conditions, here is a scanner which
provides two different interpretations of a string like ‘\verb`123.456`’. 
By default it will treat it as three tokens, the integer ‘\verb`123`’, a
dot (‘\verb`.`’), and the integer ‘\verb`456`’.  But if the string is
preceded earlier in the line by the string ‘\verb`expect-floats`’ it will
treat it as a single token, the floating-point number ‘\verb`123.456`’:


\begin{verbatim}
%{
         #include <math.h>
         %}
         %s expect
     
         %%
         expect-floats        BEGIN(expect);
     
         <expect>[0-9]+.[0-9]+      {
                     printf( "found a float, = %f\n",
                             atof( yytext ) );
                     }
         <expect>\n           {
                     /* that's the end of the line, so
                      * we need another "expect-number"
                      * before we'll recognize any more
                      * numbers
                      */
                     BEGIN(INITIAL);
                     }
     
         [0-9]+      {
                     printf( "found an integer, = %d\n",
                             atoi( yytext ) );
                     }
     
         "."         printf( "found a dot\n" );
\end{verbatim}


Here is a scanner which recognizes (and discards) C comments while
maintaining a count of the current input line.


\begin{verbatim}
%x comment
         %%
                 int line_num = 1;
     
         "/*"         BEGIN(comment);
     
         <comment>[^*\n]*        /* eat anything that's not a '*' */
         <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
         <comment>\n             ++line_num;
         <comment>"*"+"/"        BEGIN(INITIAL);
\end{verbatim}


This scanner goes to a bit of trouble to match as much
text as possible with each rule.  In general, when attempting to write
a high-speed scanner try to match as much possible in each rule, as
it's a big win.

Note that start-conditions names are really integer values and
can be stored as such.  Thus, the above could be extended in the
following fashion:


\begin{verbatim}
%x comment foo
         %%
                 int line_num = 1;
                 int comment_caller;
     
         "/*"         {
                      comment_caller = INITIAL;
                      BEGIN(comment);
                      }
     
         ...
     
         <foo>"/*"    {
                      comment_caller = foo;
                      BEGIN(comment);
                      }
     
         <comment>[^*\n]*        /* eat anything that's not a '*' */
         <comment>"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
         <comment>\n             ++line_num;
         <comment>"*"+"/"        BEGIN(comment_caller);
\end{verbatim}


Furthermore, you can access the current start condition using the
integer-valued \verb`YY_START` macro.  For example, the above
assignments to \verb`comment_caller` could instead be written


\begin{verbatim}
comment_caller = YY_START;
\end{verbatim}


Flex provides \verb`YYSTATE` as an alias for \verb`YY_START` (since that
is what's used by AT\&{}T \verb`lex` ).

For historical reasons, start conditions do not have their own
name-space within the generated scanner. The start condition names are
unmodified in the generated scanner and generated header. 
Seeoption-header. Seeoption-prefix.

Finally, here's an example of how to match C-style quoted strings using
exclusive start conditions, including expanded escape sequences (but
not including checking for a string that's too long):


\begin{verbatim}
%x str
     
         %%
                 char string_buf[MAX_STR_CONST];
                 char *string_buf_ptr;
     
     
         \"      string_buf_ptr = string_buf; BEGIN(str);
     
         <str>\"        { /* saw closing quote - all done */
                 BEGIN(INITIAL);
                 *string_buf_ptr = '\0';
                 /* return string constant token type and
                  * value to parser
                  */
                 }
     
         <str>\n        {
                 /* error - unterminated string constant */
                 /* generate error message */
                 }
     
         <str>\\[0-7]{1,3} {
                 /* octal escape sequence */
                 int result;
     
                 (void) sscanf( yytext + 1, "%o", &result );
     
                 if ( result > 0xff )
                         /* error, constant is out-of-bounds */
     
                 *string_buf_ptr++ = result;
                 }
     
         <str>\\[0-9]+ {
                 /* generate error - bad escape sequence; something
                  * like '\48' or '\0777777'
                  */
                 }
     
         <str>\\n  *string_buf_ptr++ = '\n';
         <str>\\t  *string_buf_ptr++ = '\t';
         <str>\\r  *string_buf_ptr++ = '\r';
         <str>\\b  *string_buf_ptr++ = '\b';
         <str>\\f  *string_buf_ptr++ = '\f';
     
         <str>\\(.|\n)  *string_buf_ptr++ = yytext[1];
     
         <str>[^\\\n\"]+        {
                 char *yptr = yytext;
     
                 while ( *yptr )
                         *string_buf_ptr++ = *yptr++;
                 }
\end{verbatim}


Often, such as in some of the examples above, you wind up writing a
whole bunch of rules all preceded by the same start condition(s).  Flex
makes this a little easier and cleaner by introducing a notion of start
condition.  A start condition scope is begun with:
\begin{verbatim}
<SCs>{
\end{verbatim}


where \verb`SCs` is a list of one or more start conditions.  Inside the
start condition scope, every rule automatically has the prefix \verb`SCs>` applied to it, until a ‘\verb`}`’ which matches the initial
‘\verb`{`’.  So, for example,


\begin{verbatim}
<ESC>{
             "\\n"   return '\n';
             "\\r"   return '\r';
             "\\f"   return '\f';
             "\\0"   return '\0';
         }
\end{verbatim}


is equivalent to:
\begin{verbatim}
<ESC>"\\n"  return '\n';
         <ESC>"\\r"  return '\r';
         <ESC>"\\f"  return '\f';
         <ESC>"\\0"  return '\0';
\end{verbatim}


Start condition scopes may be nested.

The following routines are available for manipulating stacks of start conditions: \verb`new_state` 

pushes the current start condition onto the top of the start condition
stack and switches to \verb`new_state` as though you had used \verb`BEGIN new_state` (recall that start condition names are also integers).

pops the top of the stack and switches to it via \verb`BEGIN` .

returns the top of the stack without altering the stack's contents.

The start condition stack grows dynamically and so has no built-in size
limitation.  If memory is exhausted, program execution aborts.

To use start condition stacks, your scanner must include a \verb`%option stack` directive (seeScanner Options).
\chapter{Multiple Input Buffers}


Some scanners (such as those which support “include” files) require
reading from several input streams.  As \verb`flex` scanners do a large
amount of buffering, one cannot control where the next input will be
read from by simply writing a \verb`YY_INPUT()` which is sensitive to
the scanning context. \verb`YY_INPUT()` is only called when the scanner
reaches the end of its buffer, which may be a long time after scanning a
statement such as an \verb`include` statement which requires switching
the input source.

To negotiate these sorts of problems, \verb`flex` provides a mechanism
for creating and switching between multiple input buffers.  An input
buffer is created by using:



which takes a \verb`FILE` pointer and a size and creates a buffer
associated with the given file and large enough to hold \verb`size` characters (when in doubt, use \verb`YY_BUF_SIZE` for the size).  It
returns a \verb`YY_BUFFER_STATE` handle, which may then be passed to
other routines (see below).The \verb`YY_BUFFER_STATE` type is a
pointer to an opaque \verb`struct yy_buffer_state` structure, so you may
safely initialize \verb`YY_BUFFER_STATE` variables to \verb`((YY_BUFFER_STATE) 0)` if you wish, and also refer to the opaque structure in order to
correctly declare input buffers in source files other than that of your
scanner.  Note that the \verb`FILE` pointer in the call to \verb`yy_create_buffer` is only used as the value ofseen by \verb`YY_INPUT` .  If you redefine \verb`YY_INPUT()` so it no longer uses, then you can safely pass a NULL \verb`FILE` pointer to \verb`yy_create_buffer` .  You select a particular buffer to scan from
using:

The above function switches the scanner's input buffer so subsequent tokens
will come from \verb`new_buffer` .  Note that \verb`yy_switch_to_buffer()` may
be used by \verb`yywrap()` to set things up for continued scanning, instead of
opening a new file and pointingat it. If you are looking for a
stack of input buffers, then you want to use \verb`yypush_buffer_state()` instead of this function. Note also that switching input sources via either \verb`yy_switch_to_buffer()` or \verb`yywrap()` doeschange the
start condition.



is used to reclaim the storage associated with a buffer.  ( \verb`buffer` can be NULL, in which case the routine does nothing.)  You can also clear
the current contents of a buffer using:



This function pushes the new buffer state onto an internal stack. The pushed
state becomes the new current state. The stack is maintained by flex and will
grow as required. This function is intended to be used instead of \verb`yy_switch_to_buffer` , when you want to change states, but preserve the
current state for later use.



This function removes the current state from the top of the stack, and deletes
it by calling \verb`yy_delete_buffer` .  The next state on the stack, if any,
becomes the new current state.



This function discards the buffer's contents,
so the next time the scanner attempts to match a token from the
buffer, it will first fill the buffer anew using \verb`YY_INPUT()` .

is an alias for \verb`yy_create_buffer()` ,
provided for compatibility with the C++ use of \verb`new` and \verb`delete` for creating and destroying dynamic objects.

 \verb`YY_CURRENT_BUFFER` macro returns a \verb`YY_BUFFER_STATE` handle to the
current buffer. It should not be used as an lvalue.

Here are two examples of using these features for writing a scanner
which expands include files (the \verb`<<EOF>>` feature is discussed below).

This first example uses yypush\_{}buffer\_{}state and yypop\_{}buffer\_{}state. Flex
maintains the stack internally.


\begin{verbatim}
/* the "incl" state is used for picking up the name
          * of an include file
          */
         %x incl
         %%
         include             BEGIN(incl);
     
         [a-z]+              ECHO;
         [^a-z\n]*\n?        ECHO;
     
         <incl>[ \t]*      /* eat the whitespace */
         <incl>[^ \t\n]+   { /* got the include file name */
                 yyin = fopen( yytext, "r" );
     
                 if ( ! yyin )
                     error( ... );
     
     			yypush_buffer_state(yy_create_buffer( yyin, YY_BUF_SIZE ));
     
                 BEGIN(INITIAL);
                 }
     
         <<EOF>> {
     			yypop_buffer_state();
     
                 if ( !YY_CURRENT_BUFFER )
                     {
                     yyterminate();
                     }
                 }
\end{verbatim}


The second example, below, does the same thing as the previous example did, but
manages its own input buffer stack manually (instead of letting flex do it).


\begin{verbatim}
/* the "incl" state is used for picking up the name
          * of an include file
          */
         %x incl
     
         %{
         #define MAX_INCLUDE_DEPTH 10
         YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
         int include_stack_ptr = 0;
         %}
     
         %%
         include             BEGIN(incl);
     
         [a-z]+              ECHO;
         [^a-z\n]*\n?        ECHO;
     
         <incl>[ \t]*      /* eat the whitespace */
         <incl>[^ \t\n]+   { /* got the include file name */
                 if ( include_stack_ptr >= MAX_INCLUDE_DEPTH )
                     {
                     fprintf( stderr, "Includes nested too deeply" );
                     exit( 1 );
                     }
     
                 include_stack[include_stack_ptr++] =
                     YY_CURRENT_BUFFER;
     
                 yyin = fopen( yytext, "r" );
     
                 if ( ! yyin )
                     error( ... );
     
                 yy_switch_to_buffer(
                     yy_create_buffer( yyin, YY_BUF_SIZE ) );
     
                 BEGIN(INITIAL);
                 }
     
         <<EOF>> {
                 if ( --include_stack_ptr  0 )
                     {
                     yyterminate();
                     }
     
                 else
                     {
                     yy_delete_buffer( YY_CURRENT_BUFFER );
                     yy_switch_to_buffer(
                          include_stack[include_stack_ptr] );
                     }
                 }
\end{verbatim}


The following routines are available for setting up input buffers for
scanning in-memory strings instead of files.  All of them create a new
input buffer for scanning the string, and return a corresponding \verb`YY_BUFFER_STATE` handle (which you should delete with \verb`yy_delete_buffer()` when done with it).  They also switch to the
new buffer using \verb`yy_switch_to_buffer()` , so the next call to \verb`yylex()` will start scanning the string.

scans a NUL-terminated string.

scans \verb`len` bytes (including possibly \verb`NUL` s) starting at location \verb`bytes` .

Note that both of these functions create and scan aof the
string or bytes.  (This may be desirable, since \verb`yylex()` modifies
the contents of the buffer it is scanning.)  You can avoid the copy by
using:



which scans in place the buffer starting at \verb`base` , consisting of \verb`size` bytes, the last two bytes of whichbe \verb`YY_END_OF_BUFFER_CHAR` (ASCII NUL).  These last two bytes are not
scanned; thus, scanning consists of \verb`base[0]` through \verb`base[size-2]` , inclusive.

If you fail to set up \verb`base` in this manner (i.e., forget the final
two \verb`YY_END_OF_BUFFER_CHAR` bytes), then \verb`yy_scan_buffer()` returns a NULL pointer instead of creating a new input buffer.

is an integral type to which you can cast an integer expression
reflecting the size of the buffer.
\chapter{End-of-File Rules}


The special rule \verb`<<EOF>>` indicates
actions which are to be taken when an end-of-file is
encountered and \verb`yywrap()` returns non-zero (i.e., indicates
no further files to process).  The action must finish
by doing one of the following things:
\begin{itemize}
\item assigningto a new input file (in previous versions of \verb`flex` , after doing the assignment you had to call the special
action \verb`YY_NEW_FILE` .  This is no longer necessary.)
\item executing a \verb`return` statement;
\item executing the special \verb`yyterminate()` action.
\item or, switching to a new buffer using \verb`yy_switch_to_buffer()` as
shown in the example above.
\end{itemize}


<<EOF>> rules may not be used with other patterns; they may only be
qualified with a list of start conditions.  If an unqualified <<EOF>>
rule is given, it applies tostart conditions which do not
already have <<EOF>> actions.  To specify an <<EOF>> rule for only the
initial start condition, use:
\begin{verbatim}
<INITIAL><<EOF>>
\end{verbatim}


These rules are useful for catching things like unclosed comments.  An
example:


\begin{verbatim}
%x quote
         %%
     
         ...other rules for dealing with quotes...
     
         <quote><<EOF>>   {
                  error( "unterminated quote" );
                  yyterminate();
                  }
        <<EOF>>  {
                  if ( *++filelist )
                      yyin = fopen( *filelist, "r" );
                  else
                     yyterminate();
                  }
\end{verbatim}

\chapter{Miscellaneous Macros}


The macro \verb`YY_USER_ACTION` can be defined to provide an action
which is always executed prior to the matched rule's action.  For
example, it could be \#{}define'd to call a routine to convert yytext to
lower-case.  When \verb`YY_USER_ACTION` is invoked, the variable \verb`yy_act` gives the number of the matched rule (rules are numbered
starting with 1).  Suppose you want to profile how often each of your
rules is matched.  The following would do the trick:


\begin{verbatim}
#define YY_USER_ACTION ++ctr[yy_act]
\end{verbatim}


where \verb`ctr` is an array to hold the counts for the different rules. 
Note that the macro \verb`YY_NUM_RULES` gives the total number of rules
(including the default rule), even if you use ‘\verb`-s)`’, so a correct
declaration for \verb`ctr` is:
\begin{verbatim}
int ctr[YY_NUM_RULES];
\end{verbatim}


The macro \verb`YY_USER_INIT` may be defined to provide an action which
is always executed before the first scan (and before the scanner's
internal initializations are done).  For example, it could be used to
call a routine to read in a data table or open a logging file.

The macro \verb`yy_set_interactive(is_interactive)` can be used to
control whether the current buffer is considered.  An
interactive buffer is processed more slowly, but must be used when the
scanner's input source is indeed interactive to avoid problems due to
waiting to fill buffers (see the discussion of the ‘\verb`-I`’ flag inScanner Options).  A non-zero value in the macro invocation marks
the buffer as interactive, a zero value as non-interactive.  Note that
use of this macro overrides \verb`%option always-interactive` or \verb`%option never-interactive` (seeScanner Options). \verb`yy_set_interactive()` must be invoked prior to beginning to scan
the buffer that is (or is not) to be considered interactive.

The macro \verb`yy_set_bol(at_bol)` can be used to control whether the
current buffer's scanning context for the next token match is done as
though at the beginning of a line.  A non-zero macro argument makes
rules anchored with ‘\verb`^`’ active, while a zero argument makes
‘\verb`^`’ rules inactive.

The macro \verb`YY_AT_BOL()` returns true if the next token scanned from
the current buffer will have ‘\verb`^`’ rules active, false otherwise.

In the generated scanner, the actions are all gathered in one large
switch statement and separated using \verb`YY_BREAK` , which may be
redefined.  By default, it is simply a \verb`break` , to separate each
rule's action from the following rule's.  Redefining \verb`YY_BREAK` allows, for example, C++ users to \#{}define YY\_{}BREAK to do nothing (while
being very careful that every rule ends with a \verb`break` or a \verb`return` !) to avoid suffering from unreachable statement warnings
where because a rule's action ends with \verb`return` , the \verb`YY_BREAK` is inaccessible.
\chapter{Values Available To the User}


This chapter summarizes the various values available to the user in the
rule actions. \verb`char *yytext` holds the text of the current token.  It may be modified but not
lengthened (you cannot append characters to the end).

If the special directive \verb`%array` appears in the first section of
the scanner description, then \verb`yytext` is instead declared \verb`char yytext[YYLMAX]` , where \verb`YYLMAX` is a macro definition
that you can redefine in the first section if you don't like the default
value (generally 8KB).  Using \verb`%array` results in somewhat slower
scanners, but the value of \verb`yytext` becomes immune to calls to \verb`unput()` , which potentially destroy its value when \verb`yytext` is
a character pointer.  The opposite of \verb`%array` is \verb`%pointer` ,
which is the default.

You cannot use \verb`%array` when generating C++ scanner classes (the
‘\verb`-+`’ flag).

 \verb`int yyleng` holds the length of the current token.

 \verb`FILE *yyin` is the file which by default \verb`flex` reads from.  It may be
redefined but doing so only makes sense before scanning begins or after
an EOF has been encountered.  Changing it in the midst of scanning will
have unexpected results since \verb`flex` buffers its input; use \verb`yyrestart()` instead.  Once scanning terminates because an
end-of-file has been seen, you can assignat the new input
file and then call the scanner again to continue scanning.

 \verb`void yyrestart( FILE *new_file )` may be called to pointat the new input file.  The
switch-over to the new file is immediate (any previously buffered-up
input is lost).  Note that calling \verb`yyrestart()` withas an argument thus throws away the current input buffer and continues
scanning the same input file.

 \verb`FILE *yyout` is the file to which \verb`ECHO` actions are done.  It can be reassigned
by the user.

 \verb`YY_CURRENT_BUFFER` returns a \verb`YY_BUFFER_STATE` handle to the current buffer.

 \verb`YY_START` returns an integer value corresponding to the current start condition. 
You can subsequently use this value with \verb`BEGIN` to return to that
start condition.
\chapter{Interfacing with Yacc}


One of the main uses of \verb`flex` is as a companion to the \verb`yacc` parser-generator. \verb`yacc` parsers expect to call a routine named \verb`yylex()` to find the next input token.  The routine is supposed to
return the type of the next token as well as putting any associated
value in the global \verb`yylval` .  To use \verb`flex` with \verb`yacc` ,
one specifies the ‘\verb`-d`’ option to \verb`yacc` to instruct it to
generate the filecontaining definitions of all the \verb`%tokens` appearing in the \verb`yacc` input.  This file is then
included in the \verb`flex` scanner.  For example, if one of the tokens
is \verb`TOK_NUMBER` , part of the scanner might look like:


\begin{verbatim}
%{
         #include "y.tab.h"
         %}
     
         %%
     
         [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
\end{verbatim}

\chapter{Scanner Options}


The various \verb`flex` options are categorized by function in the following
menu. If you want to lookup a particular option by name, SeeIndex of Scanner Options.
\begin{itemize}
\item Options for Specifying Filenames
\item Options Affecting Scanner Behavior
\item Code-Level And API Options
\item Options for Scanner Speed and Size
\item Debugging Options
\item Miscellaneous Options
\end{itemize}


Even though there are many scanner options, a typical scanner might only
specify the following options:
\begin{verbatim}
%option   8bit reentrant bison-bridge
     %option   warn nodefault
     %option   yylineno
     %option   outfile="scanner.c" header-file="scanner.h"
\end{verbatim}


The first line specifies the general type of scanner we want. The second line
specifies that we are being careful. The third line asks flex to track line
numbers. The last line tells flex what to name the files. (The options can be
specified in any order. We just divided them.)

 \verb`flex` also provides a mechanism for controlling options within the
scanner specification itself, rather than from the flex command-line. 
This is done by including \verb`%option` directives in the first section
of the scanner specification.  You can specify multiple options with a
single \verb`%option` directive, and multiple directives in the first
section of your flex input file.

Most options are given simply as names, optionally preceded by the
word ‘\verb`no`’ (with no intervening whitespace) to negate their meaning. 
The names are the same as their long-option equivalents (but without the
leading ‘\verb`--`’ ).

 \verb`flex` scans your rule actions to determine whether you use the \verb`REJECT` or \verb`yymore()` features.  The \verb`REJECT` and \verb`yymore` options are available to override its decision as to
whether you use the options, either by setting them (e.g., \verb`%option reject)` to indicate the feature is indeed used, or unsetting them to
indicate it actually is not used (e.g., \verb`%option noyymore)` .

A number of options are available for lint purists who want to suppress
the appearance of unneeded routines in the generated scanner.  Each of
the following, if unset (e.g., \verb`%option nounput` ), results in the
corresponding routine not appearing in the generated scanner:
\begin{verbatim}
input, unput
         yy_push_state, yy_pop_state, yy_top_state
         yy_scan_buffer, yy_scan_bytes, yy_scan_string
     
         yyget_extra, yyset_extra, yyget_leng, yyget_text,
         yyget_lineno, yyset_lineno, yyget_in, yyset_in,
         yyget_out, yyset_out, yyget_lval, yyset_lval,
         yyget_lloc, yyset_lloc, yyget_debug, yyset_debug
\end{verbatim}


(though \verb`yy_push_state()` and friends won't appear anyway unless
you use \verb`%option stack)` .
\section{Options for Specifying Filenames}
\verb`--header-file=FILE,` \verb`%option header-file="FILE"` instructs flex to write a C header to. This file contains
function prototypes, extern variables, and types used by the scanner. 
Only the external API is exported by the header file. Many macros that
are usable from within scanner actions are not exported to the header
file. This is due to namespace problems and the goal of a clean
external API.

While in the header, the macro \verb`yyIN_HEADER` is defined, where ‘\verb`yy`’
is substituted with the appropriate prefix.

The ‘\verb`--header-file`’ option is not compatible with the ‘\verb`--c++`’ option,
since the C++ scanner provides its own header in.

\verb`-oFILE, --outfile=FILE,` \verb`%option outfile="FILE"` directs flex to write the scanner to the fileinstead of.  If you combine ‘\verb`--outfile`’ with the ‘\verb`--stdout`’ option,
then the scanner is written tobut its \verb`#line` directives (see the ‘\verb`-l`’ option above) refer to the file.

\verb`-t, --stdout,` \verb`%option stdout` instructs \verb`flex` to write the scanner it generates to standard
output instead of.

\verb`-SFILE, --skel=FILE`overrides the default skeleton file from which \verb`flex` constructs its scanners.  You'll never need this option unless you are doing \verb`flex` maintenance or development.

\verb`--tables-file=FILE`Write serialized scanner dfa tables to FILE. The generated scanner will not
contain the tables, and requires them to be loaded at runtime. 
Seeserialization.

\verb`--tables-verify`This option is for flex development. We document it here in case you stumble
upon it by accident or in case you suspect some inconsistency in the serialized
tables.  Flex will serialize the scanner dfa tables but will also generate the
in-code tables as it normally does. At runtime, the scanner will verify that
the serialized tables match the in-code tables, instead of loading them.
\section{Options Affecting Scanner Behavior}
\verb`-i, --case-insensitive,` \verb`%option case-insensitive` instructs \verb`flex` to generate ascanner.  The
case of letters given in the \verb`flex` input patterns will be ignored,
and tokens in the input will be matched regardless of case.  The matched
text given in \verb`yytext` will have the preserved case (i.e., it will
not be folded).  For tricky behavior, seecase and character ranges.

\verb`-l, --lex-compat,` \verb`%option lex-compat` turns on maximum compatibility with the original AT\&{}T \verb`lex` implementation.  Note that this does not meancompatibility. 
Use of this option costs a considerable amount of performance, and it
cannot be used with the ‘\verb`--c++`’, ‘\verb`--full`’, ‘\verb`--fast`’, ‘\verb`-Cf`’, or
‘\verb`-CF`’ options.  For details on the compatibilities it provides, seeLex and Posix.  This option also results in the name \verb`YY_FLEX_LEX_COMPAT` being \verb`#define` 'd in the generated scanner.

\verb`-B, --batch,` \verb`%option batch` instructs \verb`flex` to generate ascanner, the opposite ofscanners generated by ‘\verb`--interactive`’ (see below).  In
general, you use ‘\verb`-B`’ when you arethat your scanner
will never be used interactively, and you want to squeeze amore performance out of it.  If your goal is instead to
squeeze out amore performance, you should be using the
‘\verb`-Cf`’ or ‘\verb`-CF`’ options, which turn on ‘\verb`--batch`’ automatically
anyway.

\verb`-I, --interactive,` \verb`%option interactive` instructs \verb`flex` to generate anscanner.  An
interactive scanner is one that only looks ahead to decide what token
has been matched if it absolutely must.  It turns out that always
looking one extra character ahead, even if the scanner has already seen
enough text to disambiguate the current token, is a bit faster than only
looking ahead when necessary.  But scanners that always look ahead give
dreadful interactive performance; for example, when a user types a
newline, it is not recognized as a newline token until they entertoken, which often means typing in another whole line.

 \verb`flex` scanners default to \verb`interactive` unless you use the
‘\verb`-Cf`’ or ‘\verb`-CF`’ table-compression options
(seePerformance).  That's because if you're looking for
high-performance you should be using one of these options, so if you
didn't, \verb`flex` assumes you'd rather trade off a bit of run-time
performance for intuitive interactive behavior.  Note also that youuse ‘\verb`--interactive`’ in conjunction with ‘\verb`-Cf`’ or
‘\verb`-CF`’.  Thus, this option is not really needed; it is on by default
for all those cases in which it is allowed.

You can force a scanner tobe interactive by using
‘\verb`--batch`’

\verb`-7, --7bit,` \verb`%option 7bit` instructs \verb`flex` to generate a 7-bit scanner, i.e., one which can
only recognize 7-bit characters in its input.  The advantage of using
‘\verb`--7bit`’ is that the scanner's tables can be up to half the size of
those generated using the ‘\verb`--8bit`’.  The disadvantage is that such
scanners often hang or crash if their input contains an 8-bit character.

Note, however, that unless you generate your scanner using the
‘\verb`-Cf`’ or ‘\verb`-CF`’ table compression options, use of ‘\verb`--7bit`’
will save only a small amount of table space, and make your scanner
considerably less portable. \verb`Flex` 's default behavior is to
generate an 8-bit scanner unless you use the ‘\verb`-Cf`’ or ‘\verb`-CF`’,
in which case \verb`flex` defaults to generating 7-bit scanners unless
your site was always configured to generate 8-bit scanners (as will
often be the case with non-USA sites).  You can tell whether flex
generated a 7-bit or an 8-bit scanner by inspecting the flag summary in
the ‘\verb`--verbose`’ output as described above.

Note that if you use ‘\verb`-Cfe`’ or ‘\verb`-CFe`’ \verb`flex` still
defaults to generating an 8-bit scanner, since usually with these
compression options full 8-bit tables are not much more expensive than
7-bit tables.

\verb`-8, --8bit,` \verb`%option 8bit` instructs \verb`flex` to generate an 8-bit scanner, i.e., one which can
recognize 8-bit characters.  This flag is only needed for scanners
generated using ‘\verb`-Cf`’ or ‘\verb`-CF`’, as otherwise flex defaults to
generating an 8-bit scanner anyway.

See the discussion of
‘\verb`--7bit`’
above for \verb`flex` 's default behavior and the tradeoffs between 7-bit
and 8-bit scanners.

\verb`--default,` \verb`%option default` generate the default rule.

\verb`--always-interactive,` \verb`%option always-interactive` instructs flex to generate a scanner which always considers its input.  Normally, on each new input file the scanner calls \verb`isatty()` in an attempt to determine whether the scanner's input
source is interactive and thus should be read a character at a time. 
When this option is used, however, then no such call is made.

\verb`--never-interactive,` \verb`--never-interactive` instructs flex to generate a scanner which never considers its input
interactive.  This is the opposite of \verb`always-interactive` .

\verb`-X, --posix,` \verb`%option posix` turns on maximum compatibility with the POSIX 1003.2-1992 definition of \verb`lex` .  Since \verb`flex` was originally designed to implement the
POSIX definition of \verb`lex` this generally involves very few changes
in behavior.  At the current writing the known differences between \verb`flex` and the POSIX standard are:
\begin{itemize}
\item In POSIX and AT\&{}T \verb`lex` , the repeat operator, ‘\verb`{}`’, has lower
precedence than concatenation (thus ‘\verb`ab{3}`’ yields ‘\verb`ababab`’). 
Most POSIX utilities use an Extended Regular Expression (ERE) precedence
that has the precedence of the repeat operator higher than concatenation
(which causes ‘\verb`ab{3}`’ to yield ‘\verb`abbb`’).  By default, \verb`flex` places the precedence of the repeat operator higher than concatenation
which matches the ERE processing of other POSIX utilities.  When either
‘\verb`--posix`’ or ‘\verb`-l`’ are specified, \verb`flex` will use the
traditional AT\&{}T and POSIX-compliant precedence for the repeat operator
where concatenation has higher precedence than the repeat operator.
\end{itemize}


\verb`--stack,` \verb`%option stack` enables the use of
start condition stacks (seeStart Conditions).

\verb`--stdinit,` \verb`%option stdinit` if set (i.e.,initializes \verb`yyin` and \verb`yyout` toand, instead of the default of.  Some existing \verb`lex` programs depend on this behavior,
even though it is not compliant with ANSI C, which does not requireandto be compile-time constant. In a
reentrant scanner, however, this is not a problem since initialization
is performed in \verb`yylex_init` at runtime.

\verb`--yylineno,` \verb`%option yylineno` directs \verb`flex` to generate a scanner
that maintains the number of the current line read from its input in the
global variable \verb`yylineno` .  This option is implied by \verb`%option lex-compat` .  In a reentrant C scanner, the macro \verb`yylineno` is
accessible regardless of the value of \verb`%option yylineno` , however, its
value is not modified by \verb`flex` unless \verb`%option yylineno` is enabled.

\verb`--yywrap,` \verb`%option yywrap` if unset (i.e., \verb`--noyywrap)` , makes the scanner not call \verb`yywrap()` upon an end-of-file, but simply assume that there are no
more files to scan (until the user pointsat a new file and
calls \verb`yylex()` again).
\section{Code-Level And API Options}
\verb`--ansi-definitions,` \verb`%option ansi-definitions` instruct flex to generate ANSI C99 definitions for functions. 
This option is enabled by default. 
If \verb`%option noansi-definitions` is specified, then the obsolete style
is generated.

\verb`--ansi-prototypes,` \verb`%option ansi-prototypes` instructs flex to generate ANSI C99 prototypes for functions. 
This option is enabled by default. 
If \verb`noansi-prototypes` is specified, then
prototypes will have empty parameter lists.

\verb`--bison-bridge,` \verb`%option bison-bridge` instructs flex to generate a C scanner that is
meant to be called by a \verb`GNU bison` parser. The scanner has minor API changes for \verb`bison` compatibility. In particular, the declaration of \verb`yylex` is modified to take an additional parameter, \verb`yylval` . 
SeeBison Bridge.

\verb`--bison-locations,` \verb`%option bison-locations` instruct flex that \verb`GNU bison`  \verb`%locations` are being used. 
This means \verb`yylex` will be passed
an additional parameter, \verb`yylloc` . This option
implies \verb`%option bison-bridge` . 
SeeBison Bridge.

\verb`-L, --noline,` \verb`%option noline` instructs \verb`flex` not to generate \verb`#line` directives.  Without this option, \verb`flex` peppers the generated scanner
with \verb`#line` directives so error messages in the actions will be correctly
located with respect to either the original \verb`flex` input file (if the errors are due to code in the input file), or(if the errors are \verb`flex` 's
fault – you should report these sorts of errors to the email address
given inReporting Bugs).

\verb`-R, --reentrant,` \verb`%option reentrant` instructs flex to generate a reentrant C scanner.  The generated scanner
may safely be used in a multi-threaded environment. The API for a
reentrant scanner is different than for a non-reentrant scanner
seeReentrant).  Because of the API difference between
reentrant and non-reentrant \verb`flex` scanners, non-reentrant flex
code must be modified before it is suitable for use with this option. 
This option is not compatible with the ‘\verb`--c++`’ option.

The option ‘\verb`--reentrant`’ does not affect the performance of
the scanner.

\verb`-+, --c++,` \verb`%option c++` specifies that you want flex to generate a C++
scanner class.  SeeCxx, for
details.

\verb`--array,` \verb`%option array` specifies that you want yytext to be an array instead of a char*

\verb`--pointer,` \verb`%option pointer` specify that \verb`yytext` should be a \verb`char *` , not an array. 
This default is \verb`char *` .

\verb`-PPREFIX, --prefix=PREFIX,` \verb`%option prefix="PREFIX"` changes the default ‘\verb`yy`’ prefix used by \verb`flex` for all
globally-visible variable and function names to instead be
‘\verb`PREFIX`’.  For example, ‘\verb`--prefix=foo`’ changes the name of \verb`yytext` to \verb`footext` .  It also changes the name of the default
output file fromto.  Here is a partial
list of the names affected:
\begin{verbatim}
yy_create_buffer
              yy_delete_buffer
              yy_flex_debug
              yy_init_buffer
              yy_flush_buffer
              yy_load_buffer_state
              yy_switch_to_buffer
              yyin
              yyleng
              yylex
              yylineno
              yyout
              yyrestart
              yytext
              yywrap
              yyalloc
              yyrealloc
              yyfree
\end{verbatim}


(If you are using a C++ scanner, then only \verb`yywrap` and \verb`yyFlexLexer` are affected.)  Within your scanner itself, you can
still refer to the global variables and functions using either version
of their name; but externally, they have the modified name.

This option lets you easily link together multiple \verb`flex` programs into the same executable.  Note, though, that using this
option also renames \verb`yywrap()` ,
so you noweither
provide your own (appropriately-named) version of the routine for your
scanner, or use \verb`%option noyywrap` ,
as linking with
‘\verb`-lfl`’
no longer provides one for you by default.

\verb`--main,` \verb`%option main` directs flex to provide a default \verb`main()` program for the
scanner, which simply calls \verb`yylex()` .  This option implies \verb`noyywrap` (see below).

\verb`--nounistd,` \verb`%option nounistd` suppresses inclusion of the non-ANSI header file. This option
is meant to target environments in whichdoes not exist. Be aware
that certain options may cause flex to generate code that relies on functions
normally found in, (e.g. \verb`isatty()` , \verb`read()` .) 
If you wish to use these functions, you will have to inform your compiler where
to find them. 
Seeoption-always-interactive. Seeoption-read.

\verb`--yyclass=NAME,` \verb`%option yyclass="NAME"` only applies when generating a C++ scanner (the ‘\verb`--c++`’ option).  It
informs \verb`flex` that you have derived \verb`NAME` as a subclass of \verb`yyFlexLexer` , so \verb`flex` will place your actions in the member
function \verb`foo::yylex()` instead of \verb`yyFlexLexer::yylex()` .  It
also generates a \verb`yyFlexLexer::yylex()` member function that emits
a run-time error (by invoking \verb`yyFlexLexer::LexerError())` if
called.  SeeCxx.
\section{Options for Scanner Speed and Size}
\verb`-C[aefFmr]`controls the degree of table compression and, more generally, trade-offs
between small scanners and fast scanners.\verb`-C`A lone ‘\verb`-C`’ specifies that the scanner tables should be compressed
but neither equivalence classes nor meta-equivalence classes should be
used.

\verb`-Ca, --align,` \verb`%option align` (“align”) instructs flex to trade off larger tables in the
generated scanner for faster performance because the elements of
the tables are better aligned for memory access and computation.  On some
RISC architectures, fetching and manipulating longwords is more efficient
than with smaller-sized units such as shortwords.  This option can
quadruple the size of the tables used by your scanner.

\verb`-Ce, --ecs,` \verb`%option ecs` directs \verb`flex` to construct, i.e., sets
of characters which have identical lexical properties (for example, if
the only appearance of digits in the \verb`flex` input is in the
character class “[0-9]” then the digits '0', '1', ..., '9' will all be
put in the same equivalence class).  Equivalence classes usually give
dramatic reductions in the final table/object file sizes (typically a
factor of 2-5) and are pretty cheap performance-wise (one array look-up
per character scanned).

\verb`-Cf`specifies that thescanner tables should be generated - \verb`flex` should not compress the tables by taking advantages of
similar transition functions for different states.

\verb`-CF`specifies that the alternate fast scanner representation (described
above under the ‘\verb`--fast`’ flag) should be used.  This option cannot be
used with ‘\verb`--c++`’.

\verb`-Cm, --meta-ecs,` \verb`%option meta-ecs` directs \verb`flex` to construct,
which are sets of equivalence classes (or characters, if equivalence
classes are not being used) that are commonly used together.  Meta-equivalence
classes are often a big win when using compressed tables, but they
have a moderate performance impact (one or two \verb`if` tests and one
array look-up per character scanned).

\verb`-Cr, --read,` \verb`%option read` causes the generated scanner touse of the standard I/O
library ( \verb`stdio` ) for input.  Instead of calling \verb`fread()` or \verb`getc()` , the scanner will use the \verb`read()` system call,
resulting in a performance gain which varies from system to system, but
in general is probably negligible unless you are also using ‘\verb`-Cf`’
or ‘\verb`-CF`’.  Using ‘\verb`-Cr`’ can cause strange behavior if, for
example, you read fromusing \verb`stdio` prior to calling
the scanner (because the scanner will miss whatever text your previous
reads left in the \verb`stdio` input buffer).  ‘\verb`-Cr`’ has no effect
if you define \verb`YY_INPUT()` (seeGenerated Scanner).

The options ‘\verb`-Cf`’ or ‘\verb`-CF`’ and ‘\verb`-Cm`’ do not make sense
together - there is no opportunity for meta-equivalence classes if the
table is not being compressed.  Otherwise the options may be freely
mixed, and are cumulative.

The default setting is ‘\verb`-Cem`’, which specifies that \verb`flex` should generate equivalence classes and meta-equivalence classes.  This
setting provides the highest degree of table compression.  You can trade
off faster-executing scanners at the cost of larger tables with the
following generally being true:
\begin{verbatim}
slowest & smallest
                    -Cem
                    -Cm
                    -Ce
                    -C
                    -C{f,F}e
                    -C{f,F}
                    -C{f,F}a
              fastest & largest
\end{verbatim}


Note that scanners with the smallest tables are usually generated and
compiled the quickest, so during development you will usually want to
use the default, maximal compression.

‘\verb`-Cfe`’ is often a good compromise between speed and size for
production scanners.

\verb`-f, --full,` \verb`%option full` specifies. 
No table compression is done and \verb`stdio` is bypassed. 
The result is large but fast.  This option is equivalent to
‘\verb`--Cfr`’

\verb`-F, --fast,` \verb`%option fast` specifies that thescanner table representation should be
used (and \verb`stdio` bypassed).  This representation is about as fast
as the full table representation ‘\verb`--full`’, and for some sets of
patterns will be considerably smaller (and for others, larger).  In
general, if the pattern set contains bothand a
catch-all,rule, such as in the set:
\begin{verbatim}
"case"    return TOK_CASE;
              "switch"  return TOK_SWITCH;
              ...
              "default" return TOK_DEFAULT;
              [a-z]+    return TOK_ID;
\end{verbatim}


then you're better off using the full table representation.  If only
therule is present and you then use a hash table or some such
to detect the keywords, you're better off using
‘\verb`--fast`’.

This option is equivalent to ‘\verb`-CFr`’.  It cannot be used
with ‘\verb`--c++`’.
\section{Debugging Options}
\verb`-b, --backup,` \verb`%option backup` Generate backing-up information to.  This is a list of
scanner states which require backing up and the input characters on
which they do so.  By adding rules one can remove backing-up states.  Ifbacking-up states are eliminated and ‘\verb`-Cf`’ or \verb`-CF` is used, the generated scanner will run faster (see the ‘\verb`--perf-report`’ flag). 
Only users who wish to squeeze every last cycle out of their scanners
need worry about this option.  (seePerformance).

\verb`-d, --debug,` \verb`%option debug` makes the generated scanner run inmode.  Whenever a pattern
is recognized and the global variable \verb`yy_flex_debug` is non-zero
(which is the default), the scanner will write toa line
of the form:
\begin{verbatim}
-accepting rule at line 53 ("the matched text")
\end{verbatim}


The line number refers to the location of the rule in the file defining
the scanner (i.e., the file that was fed to flex).  Messages are also
generated when the scanner backs up, accepts the default rule, reaches
the end of its input buffer (or encounters a NUL; at this point, the two
look the same as far as the scanner's concerned), or reaches an
end-of-file.

\verb`-p, --perf-report,` \verb`%option perf-report` generates a performance report to.  The report consists of
comments regarding features of the \verb`flex` input file which will
cause a serious loss of performance in the resulting scanner.  If you
give the flag twice, you will also get comments regarding features that
lead to minor performance losses.

Note that the use of \verb`REJECT` , and
variable trailing context (seeLimitations) entails a substantial
performance penalty; use of \verb`yymore()` , the ‘\verb`^`’ operator, and
the ‘\verb`--interactive`’ flag entail minor performance penalties.

\verb`-s, --nodefault,` \verb`%option nodefault` causes the(that unmatched scanner input is echoed
toto be suppressed.  If the scanner encounters input
that does not match any of its rules, it aborts with an error.  This
option is useful for finding holes in a scanner's rule set.

\verb`-T, --trace,` \verb`%option trace` makes \verb`flex` run inmode.  It will generate a lot of
messages toconcerning the form of the input and the
resultant non-deterministic and deterministic finite automata.  This
option is mostly for use in maintaining \verb`flex` .

\verb`-w, --nowarn,` \verb`%option nowarn` suppresses warning messages.

\verb`-v, --verbose,` \verb`%option verbose` specifies that \verb`flex` should write toa summary of
statistics regarding the scanner it generates.  Most of the statistics
are meaningless to the casual \verb`flex` user, but the first line
identifies the version of \verb`flex` (same as reported by ‘\verb`--version`’),
and the next line the flags used when generating the scanner, including
those that are on by default.

\verb`--warn,` \verb`%option warn` warn about certain things. In particular, if the default rule can be
matched but no default rule has been given, the flex will warn you. 
We recommend using this option always.
\section{Miscellaneous Options}
\verb`-c`A do-nothing option included for POSIX compliance.

\verb`-h, -?, --help`generates a “help” summary of \verb`flex` 's options toand then exits.

\verb`-n`Another do-nothing option included for
POSIX compliance.

\verb`-V, --version`prints the version number toand exits.
\chapter{Performance Considerations}


The main design goal of \verb`flex` is that it generate high-performance
scanners.  It has been optimized for dealing well with large sets of
rules.  Aside from the effects on scanner speed of the table compression
‘\verb`-C`’ options outlined above, there are a number of options/actions
which degrade performance.  These are, from most expensive to least:


\begin{verbatim}
REJECT
         arbitrary trailing context
     
         pattern sets that require backing up
         %option yylineno
         %array
     
         %option interactive
         %option always-interactive
     
         ^ beginning-of-line operator
         yymore()
\end{verbatim}


with the first two all being quite expensive and the last two being
quite cheap.  Note also that \verb`unput()` is implemented as a routine
call that potentially does quite a bit of work, while \verb`yyless()` is
a quite-cheap macro. So if you are just putting back some excess text
you scanned, use \verb`yyless()` .

 \verb`REJECT` should be avoided at all costs when performance is
important.  It is a particularly expensive option.

There is one case when \verb`%option yylineno` can be expensive. That is when
your patterns match long tokens that couldcontain a newline
character. There is no performance penalty for rules that can not possibly
match newlines, since flex does not need to check them for newlines.  In
general, you should avoid rules such as \verb`[^f]+` , which match very long
tokens, including newlines, and may possibly match your entire file! A better
approach is to separate \verb`[^f]+` into two rules:
\begin{verbatim}
%option yylineno
     %%
         [^f\n]+
         \n+
\end{verbatim}


The above scanner does not incur a performance penalty.

Getting rid of backing up is messy and often may be an enormous amount
of work for a complicated scanner.  In principal, one begins by using
the ‘\verb`-b`’ flag to generate afile.  For example,
on the input:


\begin{verbatim}
%%
         foo        return TOK_KEYWORD;
         foobar     return TOK_KEYWORD;
\end{verbatim}


the file looks like:
\begin{verbatim}
State #6 is non-accepting -
          associated rule line numbers:
                2       3
          out-transitions: [ o ]
          jam-transitions: EOF [ \001-n  p-\177 ]
     
         State #8 is non-accepting -
          associated rule line numbers:
                3
          out-transitions: [ a ]
          jam-transitions: EOF [ \001-`  b-\177 ]
     
         State #9 is non-accepting -
          associated rule line numbers:
                3
          out-transitions: [ r ]
          jam-transitions: EOF [ \001-q  s-\177 ]
     
         Compressed tables always back up.
\end{verbatim}


The first few lines tell us that there's a scanner state in which it can
make a transition on an 'o' but not on any other character, and that in
that state the currently scanned text does not match any rule.  The
state occurs when trying to match the rules found at lines 2 and 3 in
the input file.  If the scanner is in that state and then reads
something other than an 'o', it will have to back up to find a rule
which is matched.  With a bit of headscratching one can see that this
must be the state it's in when it has seen ‘\verb`fo`’.  When this has
happened, if anything other than another ‘\verb`o`’ is seen, the scanner
will have to back up to simply match the ‘\verb`f`’ (by the default rule).

The comment regarding State \#{}8 indicates there's a problem when
‘\verb`foob`’ has been scanned.  Indeed, on any character other than an
‘\verb`a`’, the scanner will have to back up to accept "foo".  Similarly,
the comment for State \#{}9 concerns when ‘\verb`fooba`’ has been scanned and
an ‘\verb`r`’ does not follow.

The final comment reminds us that there's no point going to all the
trouble of removing backing up from the rules unless we're using
‘\verb`-Cf`’ or ‘\verb`-CF`’, since there's no performance gain doing so
with compressed scanners.

The way to remove the backing up is to add “error” rules:


\begin{verbatim}
%%
         foo         return TOK_KEYWORD;
         foobar      return TOK_KEYWORD;
     
         fooba       |
         foob        |
         fo          {
                     /* false alarm, not really a keyword */
                     return TOK_ID;
                     }
\end{verbatim}


Eliminating backing up among a list of keywords can also be done using a
“catch-all” rule:


\begin{verbatim}
%%
         foo         return TOK_KEYWORD;
         foobar      return TOK_KEYWORD;
     
         [a-z]+      return TOK_ID;
\end{verbatim}


This is usually the best solution when appropriate.

Backing up messages tend to cascade.  With a complicated set of rules
it's not uncommon to get hundreds of messages.  If one can decipher
them, though, it often only takes a dozen or so rules to eliminate the
backing up (though it's easy to make a mistake and have an error rule
accidentally match a valid token.  A possible future \verb`flex` feature
will be to automatically add rules to eliminate backing up).

It's important to keep in mind that you gain the benefits of eliminating
backing up only if you eliminateinstance of backing up. 
Leaving just one means you gain nothing.

trailing context (where both the leading and trailing
parts do not have a fixed length) entails almost the same performance
loss as \verb`REJECT` (i.e., substantial).  So when possible a rule
like:


\begin{verbatim}
%%
         mouse|rat/(cat|dog)   run();
\end{verbatim}


is better written:
\begin{verbatim}
%%
         mouse/cat|dog         run();
         rat/cat|dog           run();
\end{verbatim}


or as
\begin{verbatim}
%%
         mouse|rat/cat         run();
         mouse|rat/dog         run();
\end{verbatim}


Note that here the special '|' action doesprovide any
savings, and can even make things worse (seeLimitations).

Another area where the user can increase a scanner's performance (and
one that's easier to implement) arises from the fact that the longer the
tokens matched, the faster the scanner will run.  This is because with
long tokens the processing of most input characters takes place in the
(short) inner scanning loop, and does not often have to go through the
additional work of setting up the scanning environment (e.g., \verb`yytext` ) for the action.  Recall the scanner for C comments:


\begin{verbatim}
%x comment
         %%
                 int line_num = 1;
     
         "/*"         BEGIN(comment);
     
         <comment>[^*\n]*
         <comment>"*"+[^*/\n]*
         <comment>\n             ++line_num;
         <comment>"*"+"/"        BEGIN(INITIAL);
\end{verbatim}


This could be sped up by writing it as:
\begin{verbatim}
%x comment
         %%
                 int line_num = 1;
     
         "/*"         BEGIN(comment);
     
         <comment>[^*\n]*
         <comment>[^*\n]*\n      ++line_num;
         <comment>"*"+[^*/\n]*
         <comment>"*"+[^*/\n]*\n ++line_num;
         <comment>"*"+"/"        BEGIN(INITIAL);
\end{verbatim}


Now instead of each newline requiring the processing of another action,
recognizing the newlines is distributed over the other rules to keep the
matched text as long as possible.  Note thatrules doesslow down the scanner!  The speed of the scanner is
independent of the number of rules or (modulo the considerations given
at the beginning of this section) how complicated the rules are with
regard to operators such as ‘\verb`*`’ and ‘\verb`|`’.

A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line
and with no other extraneous characters, and recognize all the
keywords.  A natural first approach is:


\begin{verbatim}
%%
         asm      |
         auto     |
         break    |
         ... etc ...
         volatile |
         while    /* it's a keyword */
     
         .|\n     /* it's not a keyword */
\end{verbatim}


To eliminate the back-tracking, introduce a catch-all rule:
\begin{verbatim}
%%
         asm      |
         auto     |
         break    |
         ... etc ...
         volatile |
         while    /* it's a keyword */
     
         [a-z]+   |
         .|\n     /* it's not a keyword */
\end{verbatim}


Now, if it's guaranteed that there's exactly one word per line, then we
can reduce the total number of matches by a half by merging in the
recognition of newlines with that of the other tokens:
\begin{verbatim}
%%
         asm\n    |
         auto\n   |
         break\n  |
         ... etc ...
         volatile\n |
         while\n  /* it's a keyword */
     
         [a-z]+\n |
         .|\n     /* it's not a keyword */
\end{verbatim}


One has to be careful here, as we have now reintroduced backing up
into the scanner.  In particular, whileknow that there will never be any characters in the input stream
other than letters or newlines, \verb`flex` can't figure this out, and it will plan for possibly needing to back up
when it has scanned a token like ‘\verb`auto`’ and then the next character
is something other than a newline or a letter.  Previously it would
then just match the ‘\verb`auto`’ rule and be done, but now it has no ‘\verb`auto`’
rule, only a ‘\verb`auto\n`’ rule.  To eliminate the possibility of backing up,
we could either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and therefore don't
how it's classified, we can introduce one more catch-all rule, this
one which doesn't include a newline:
\begin{verbatim}
%%
         asm\n    |
         auto\n   |
         break\n  |
         ... etc ...
         volatile\n |
         while\n  /* it's a keyword */
     
         [a-z]+\n |
         [a-z]+   |
         .|\n     /* it's not a keyword */
\end{verbatim}


Compiled with ‘\verb`-Cf`’, this is about as fast as one can get a \verb`flex` scanner to go for this particular problem.

A final note: \verb`flex` is slow when matching \verb`NUL` s,
particularly when a token contains multiple \verb`NUL` s.  It's best to
write rules which matchamounts of text if it's anticipated
that the text will often include \verb`NUL` s.

Another final note regarding performance: as mentioned inMatching, dynamically resizing \verb`yytext` to accommodate huge
tokens is a slow process because it presently requires that the (huge)
token be rescanned from the beginning.  Thus if performance is vital,
you should attempt to match “large” quantities of text but not
“huge” quantities, where the cutoff between the two is at about 8K
characters per token.
\chapter{Generating C++ Scanners}


: the present form of the scanning class isand may change considerably between major releases.

 \verb`flex` provides two different ways to generate scanners for use
with C++.  The first way is to simply compile a scanner generated by \verb`flex` using a C++ compiler instead of a C compiler.  You should
not encounter any compilation errors (seeReporting Bugs).  You can
then use C++ code in your rule actions instead of C code.  Note that the
default input source for your scanner remains, and default
echoing is still done to.  Both of these remain \verb`FILE *` variables and not C++.

You can also use \verb`flex` to generate a C++ scanner class, using the
‘\verb`-+`’ option (or, equivalently, \verb`%option c++)` , which is
automatically specified if the name of the \verb`flex` executable ends
in a '+', such as \verb`flex++` .  When using this option, \verb`flex` defaults to generating the scanner to the fileinstead
of.  The generated scanner includes the header file, which defines the interface to two C++ classes.

The first class, \verb`FlexLexer` ,
provides an abstract base class defining the general scanner class
interface.  It provides the following member functions: \verb`const char* YYText()` returns the text of the most recently matched token, the equivalent of \verb`yytext` .

 \verb`int YYLeng()` returns the length of the most recently matched token, the equivalent of \verb`yyleng` .

 \verb`int lineno() const` returns the current input line number (see \verb`%option yylineno)` , or \verb`1` if \verb`%option yylineno` was not used.

 \verb`void set_debug( int flag )` sets the debugging flag for the scanner, equivalent to assigning to \verb`yy_flex_debug` (seeScanner Options).  Note that you must build
the scanner using \verb`%option debug` to include debugging information
in it.

 \verb`int debug() const` returns the current setting of the debugging flag.

Also provided are member functions equivalent to \verb`yy_switch_to_buffer()` , \verb`yy_create_buffer()` (though the
first argument is an \verb`istream*` object pointer and not a \verb`FILE*)` , \verb`yy_flush_buffer()` , \verb`yy_delete_buffer()` , and \verb`yyrestart()` (again, the first argument is a \verb`istream*` object pointer).

The second class defined inis \verb`yyFlexLexer` ,
which is derived from \verb`FlexLexer` .  It defines the following
additional member functions: \verb`yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )` constructs a \verb`yyFlexLexer` object using the given streams for input
and output.  If not specified, the streams default to \verb`cin` and \verb`cout` , respectively.

 \verb`virtual int yylex()` performs the same role is \verb`yylex()` does for ordinary \verb`flex` scanners: it scans the input stream, consuming tokens, until a rule's
action returns a value.  If you derive a subclass \verb`S` from \verb`yyFlexLexer` and want to access the member functions and variables
of \verb`S` inside \verb`yylex()` , then you need to use \verb`%option yyclass="S"` to inform \verb`flex` that you will be using that subclass
instead of \verb`yyFlexLexer` .  In this case, rather than generating \verb`yyFlexLexer::yylex()` , \verb`flex` generates \verb`S::yylex()` (and also generates a dummy \verb`yyFlexLexer::yylex()` that calls \verb`yyFlexLexer::LexerError()` if called).

 \verb`virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)` reassigns \verb`yyin` to \verb`new_in` (if non-null) and \verb`yyout` to \verb`new_out` (if non-null), deleting the previous input buffer if \verb`yyin` is reassigned. \verb`int yylex( istream* new_in, ostream* new_out = 0 )` first switches the input streams via \verb`switch_streams( new_in, new_out )` and then returns the value of \verb`yylex()` .

In addition, \verb`yyFlexLexer` defines the following protected virtual
functions which you can redefine in derived classes to tailor the
scanner: \verb`virtual int LexerInput( char* buf, int max_size )` reads up to \verb`max_size` characters into \verb`buf` and returns the
number of characters read.  To indicate end-of-input, return 0
characters.  Note that \verb`interactive` scanners (see the ‘\verb`-B`’
and ‘\verb`-I`’ flags inScanner Options) define the macro \verb`YY_INTERACTIVE` .  If you redefine \verb`LexerInput()` and need to
take different actions depending on whether or not the scanner might be
scanning an interactive input source, you can test for the presence of
this name via \verb`#ifdef` statements.

 \verb`virtual void LexerOutput( const char* buf, int size )` writes out \verb`size` characters from the buffer \verb`buf` , which, while \verb`NUL` -terminated, may also contain internal \verb`NUL` s if the
scanner's rules can match text with \verb`NUL` s in them.

 \verb`virtual void LexerError( const char* msg )` reports a fatal error message.  The default version of this function
writes the message to the stream \verb`cerr` and exits.

Note that a \verb`yyFlexLexer` object contains itsscanning state.  Thus you can use such objects to create reentrant
scanners, but see alsoReentrant.  You can instantiate multiple
instances of the same \verb`yyFlexLexer` class, and you can also combine
multiple C++ scanner classes together in the same program using the
‘\verb`-P`’ option discussed above.

Finally, note that the \verb`%array` feature is not available to C++
scanner classes; you must use \verb`%pointer` (the default).

Here is an example of a simple C++ scanner:


\begin{verbatim}
// An example of using the flex C++ scanner class.
     
         %{
         #include <iostream>
         using namespace std;
         int mylineno = 0;
         %}
     
         %option noyywrap
     
         string  \"[^\n"]+\"
     
         ws      [ \t]+
     
         alpha   [A-Za-z]
         dig     [0-9]
         name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
         num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
         num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
         number  {num1}|{num2}
     
         %%
     
         {ws}    /* skip blanks and tabs */
     
         "/*"    {
                 int c;
     
                 while((c = yyinput()) != 0)
                     {
                     if(c == '\n')
                         ++mylineno;
     
                     else if(c == '*')
                         {
                         if((c = yyinput()) == '/')
                             break;
                         else
                             unput(c);
                         }
                     }
                 }
     
         {number}  cout << "number " << YYText() << '\n';
     
         \n        mylineno++;
     
         {name}    cout << "name " << YYText() << '\n';
     
         {string}  cout << "string " << YYText() << '\n';
     
         %%
     
         int main( int /* argc */, char** /* argv */ )
         {
             FlexLexer* lexer = new yyFlexLexer;
             while(lexer->yylex() != 0)
                 ;
             return 0;
         }
\end{verbatim}


If you want to create multiple (different) lexer classes, you use the
‘\verb`-P`’ flag (or the \verb`prefix=` option) to rename each \verb`yyFlexLexer` to some other ‘\verb`xxFlexLexer`’.  You then can
includein your other sources once per lexer class,
first renaming \verb`yyFlexLexer` as follows:


\begin{verbatim}
#undef yyFlexLexer
         #define yyFlexLexer xxFlexLexer
         #include <FlexLexer.h>
     
         #undef yyFlexLexer
         #define yyFlexLexer zzFlexLexer
         #include <FlexLexer.h>
\end{verbatim}


if, for example, you used \verb`%option prefix="xx"` for one of your
scanners and \verb`%option prefix="zz"` for the other.
\chapter{Reentrant C Scanners}


 \verb`flex` has the ability to generate a reentrant C scanner. This is
accomplished by specifying \verb`%option reentrant` (‘\verb`-R`’) The generated
scanner is both portable, and safe to use in one or more separate threads of
control.  The most common use for reentrant scanners is from within
multi-threaded applications.  Any thread may create and execute a reentrant \verb`flex` scanner without the need for synchronization with other threads.
\begin{itemize}
\item Reentrant Uses
\item Reentrant Overview
\item Reentrant Example
\item Reentrant Detail
\item Reentrant Functions
\end{itemize}

\section{Uses for Reentrant Scanners}


However, there are other uses for a reentrant scanner.  For example, you
could scan two or more files simultaneously to implement a \verb`diff` at
the token level (i.e., instead of at the character level):


\begin{verbatim}
/* Example of maintaining more than one active scanner. */
     
         do {
             int tok1, tok2;
     
             tok1 = yylex( scanner_1 );
             tok2 = yylex( scanner_2 );
     
             if( tok1 != tok2 )
                 printf("Files are different.");
     
        } while ( tok1 && tok2 );
\end{verbatim}


Another use for a reentrant scanner is recursion. 
(Note that a recursive scanner can also be created using a non-reentrant scanner and
buffer states. SeeMultiple Input Buffers.)

The following crude scanner supports the ‘\verb`eval`’ command by invoking
another instance of itself.


\begin{verbatim}
/* Example of recursive invocation. */
     
         %option reentrant
     
         %%
         "eval(".+")"  {
                           yyscan_t scanner;
                           YY_BUFFER_STATE buf;
     
                           yylex_init( &scanner );
                           yytext[yyleng-1] = ' ';
     
                           buf = yy_scan_string( yytext + 5, scanner );
                           yylex( scanner );
     
                           yy_delete_buffer(buf,scanner);
                           yylex_destroy( scanner );
                      }
         ...
         %%
\end{verbatim}

\section{An Overview of the Reentrant API}


The API for reentrant scanners is different than for non-reentrant
scanners. Here is a quick overview of the API:

\verb`%option reentrant` 

\begin{itemize} 
\item All functions take one additional argument: \verb`yyscanner`
\item All global variables are replaced by their macro equivalents. 
(We tell you this because it may be important to you during debugging.)
\item  \verb`yylex_init` and \verb`yylex_destroy` must be called before and
after \verb`yylex` , respectively.
\item Accessor methods (get/set functions) provide access to common \verb`flex` variables.
\item User-specific data can be stored in \verb`yyextra` .
\end{itemize}

\section{Reentrant Example}


First, an example of a reentrant scanner:
\begin{verbatim}
/* This scanner prints "//" comments. */
     
         %option reentrant stack noyywrap
         %x COMMENT
     
         %%
     
         "//"                 yy_push_state( COMMENT, yyscanner);
         .|\n
     
         <COMMENT>\n          yy_pop_state( yyscanner );
         <COMMENT>[^\n]+      fprintf( yyout, "%s\n", yytext);
     
         %%
     
         int main ( int argc, char * argv[] )
         {
             yyscan_t scanner;
     
             yylex_init ( &scanner );
             yylex ( scanner );
             yylex_destroy ( scanner );
         return 0;
        }
\end{verbatim}

\section{The Reentrant API in Detail}


Here are the things you need to do or know to use the reentrant C API of \verb`flex` .
\begin{itemize}
\item Specify Reentrant
\item Extra Reentrant Argument
\item Global Replacement
\item Init and Destroy Functions
\item Accessor Methods
\item Extra Data
\item About yyscan\_{}t
\end{itemize}



Next:Extra Reentrant Argument,
Previous:Reentrant Detail,
Up:Reentrant Detail

\%{}option reentrant (–reentrant) must be specified.

Notice that \verb`%option reentrant` is specified in the above example
(seeReentrant Example. Had this option not been specified, \verb`flex` would have happily generated a non-reentrant scanner without
complaining. You may explicitly specify \verb`%option noreentrant` , if
you dowant a reentrant scanner, although it is not
necessary. The default is to generate a non-reentrant scanner.


Next:Global Replacement,
Previous:Specify Reentrant,
Up:Reentrant Detail

All functions take one additional argument: \verb`yyscanner` .

Notice that the calls to \verb`yy_push_state` and \verb`yy_pop_state` both have an argument, \verb`yyscanner` , that is not present in a
non-reentrant scanner.  Here are the declarations of \verb`yy_push_state` and \verb`yy_pop_state` in the reentrant scanner:
\begin{verbatim}
static void yy_push_state  ( int new_state , yyscan_t yyscanner ) ;
         static void yy_pop_state  ( yyscan_t yyscanner  ) ;
\end{verbatim}


Notice that the argument \verb`yyscanner` appears in the declaration of
both functions.  In fact, all \verb`flex` functions in a reentrant
scanner have this additional argument.  It is always the last argument
in the argument list, it is always of type \verb`yyscan_t` (which is
typedef'd to \verb`void *` ) and it is
always named \verb`yyscanner` .  As you may have guessed, \verb`yyscanner` is a pointer to an opaque data structure encapsulating
the current state of the scanner.  For a list of function declarations,
seeReentrant Functions. Note that preprocessor macros, such as \verb`BEGIN` , \verb`ECHO` , and \verb`REJECT` , do not take this
additional argument.


Next:Init and Destroy Functions,
Previous:Extra Reentrant Argument,
Up:Reentrant Detail

All global variables in traditional flex have been replaced by macro equivalents.

Note that in the above example, \verb`yyout` and \verb`yytext` are
not plain variables. These are macros that will expand to their equivalent lvalue. 
All of the familiar \verb`flex` globals have been replaced by their macro
equivalents. In particular, \verb`yytext` , \verb`yyleng` , \verb`yylineno` , \verb`yyin` , \verb`yyout` , \verb`yyextra` , \verb`yylval` , and \verb`yylloc` are macros. You may safely use these macros in actions as if they were plain
variables. We only tell you this so you don't expect to link to these variables
externally. Currently, each macro expands to a member of an internal struct, e.g.,
\begin{verbatim}
#define yytext (((struct yyguts_t*)yyscanner)->yytext_r)
\end{verbatim}


One important thing to remember about \verb`yytext` and friends is that \verb`yytext` is not a global variable in a reentrant
scanner, you can not access it directly from outside an action or from
other functions. You must use an accessor method, e.g., \verb`yyget_text` ,
to accomplish this. (See below).


Next:Accessor Methods,
Previous:Global Replacement,
Up:Reentrant Detail

 \verb`yylex_init` and \verb`yylex_destroy` must be called before and
after \verb`yylex` , respectively.
\begin{verbatim}
int yylex_init ( yyscan_t * ptr_yy_globals ) ;
         int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t * ptr_yy_globals ) ;
         int yylex ( yyscan_t yyscanner ) ;
         int yylex_destroy ( yyscan_t yyscanner ) ;
\end{verbatim}


The function \verb`yylex_init` must be called before calling any other
function. The argument to \verb`yylex_init` is the address of an
uninitialized pointer to be filled in by \verb`yylex_init` , overwriting
any previous contents. The function \verb`yylex_init_extra` may be used
instead, taking as its first argument a variable of type \verb`YY_EXTRA_TYPE` . 
See the section on yyextra, below, for more details.

The value stored in \verb`ptr_yy_globals` should
thereafter be passed to \verb`yylex` and \verb`yylex_destroy` .  Flex
does not save the argument passed to \verb`yylex_init` , so it is safe to
pass the address of a local pointer to \verb`yylex_init` so long as it remains
in scope for the duration of all calls to the scanner, up to and including
the call to \verb`yylex_destroy` .

The function \verb`yylex` should be familiar to you by now. The reentrant version
takes one argument, which is the value returned (via an argument) by \verb`yylex_init` .  Otherwise, it behaves the same as the non-reentrant
version of \verb`yylex` .

Both \verb`yylex_init` and \verb`yylex_init_extra` returns 0 (zero) on success,
or non-zero on failure, in which case errno is set to one of the following values:
\begin{itemize}
\item ENOMEM
Memory allocation error. Seememory-management.
\item EINVAL
Invalid argument.
\end{itemize}


The function \verb`yylex_destroy` should be
called to free resources used by the scanner. After \verb`yylex_destroy` is called, the contents of \verb`yyscanner` should not be used.  Of
course, there is no need to destroy a scanner if you plan to reuse it. 
A \verb`flex` scanner (both reentrant and non-reentrant) may be
restarted by calling \verb`yyrestart` .

Below is an example of a program that creates a scanner, uses it, then destroys
it when done:
\begin{verbatim}
int main ()
         {
             yyscan_t scanner;
             int tok;
     
             yylex_init(&scanner);
     
             while ((tok=yylex(scanner)) > 0)
                 printf("tok=%d  yytext=%s\n", tok, yyget_text(scanner));
     
             yylex_destroy(scanner);
             return 0;
         }
\end{verbatim}



Next:Extra Data,
Previous:Init and Destroy Functions,
Up:Reentrant Detail

Accessor methods (get/set functions) provide access to common \verb`flex` variables.

Many scanners that you build will be part of a larger project. Portions
of your project will need access to \verb`flex` values, such as \verb`yytext` .  In a non-reentrant scanner, these values are global, so
there is no problem accessing them. However, in a reentrant scanner, there are no
global \verb`flex` values. You can not access them directly.  Instead,
you must access \verb`flex` values using accessor methods (get/set
functions). Each accessor method is named \verb`yyget_NAME` or \verb`yyset_NAME` , where \verb`NAME` is the name of the \verb`flex` variable you want. For example:


\begin{verbatim}
/* Set the last character of yytext to NULL. */
         void chop ( yyscan_t scanner )
         {
             int len = yyget_leng( scanner );
             yyget_text( scanner )[len - 1] = '\0';
         }
\end{verbatim}


The above code may be called from within an action like this:
\begin{verbatim}
%%
         .+\n    { chop( yyscanner );}
\end{verbatim}


You may find that \verb`%option header-file` is particularly useful for generating
prototypes of all the accessor functions. Seeoption-header.


Next:About yyscan\_{}t,
Previous:Accessor Methods,
Up:Reentrant Detail

User-specific data can be stored in \verb`yyextra` .

In a reentrant scanner, it is unwise to use global variables to
communicate with or maintain state between different pieces of your program. 
However, you may need access to external data or invoke external functions
from within the scanner actions. 
Likewise, you may need to pass information to your scanner
(e.g., open file descriptors, or database connections). 
In a non-reentrant scanner, the only way to do this would be through the
use of global variables. \verb`Flex` allows you to store arbitrary, “extra” data in a scanner. 
This data is accessible through the accessor methods \verb`yyget_extra` and \verb`yyset_extra` from outside the scanner, and through the shortcut macro \verb`yyextra` from within the scanner itself. They are defined as follows:


\begin{verbatim}
#define YY_EXTRA_TYPE  void*
         YY_EXTRA_TYPE  yyget_extra ( yyscan_t scanner );
         void           yyset_extra ( YY_EXTRA_TYPE arbitrary_data , yyscan_t scanner);
\end{verbatim}


In addition, an extra form of \verb`yylex_init` is provided, \verb`yylex_init_extra` . This function is provided so that the yyextra value can
be accessed from within the very first yyalloc, used to allocate
the scanner itself.

By default, \verb`YY_EXTRA_TYPE` is defined as type \verb`void *` .  You
may redefine this type using \verb`%option extra-type="your_type"` in
the scanner:


\begin{verbatim}
/* An example of overriding YY_EXTRA_TYPE. */
         %{
         #include <sys/stat.h>
         #include <unistd.h>
         %}
         %option reentrant
         %option extra-type="struct stat *"
         %%
     
         __filesize__     printf( "%ld", yyextra->st_size  );
         __lastmod__      printf( "%ld", yyextra->st_mtime );
         %%
         void scan_file( char* filename )
         {
             yyscan_t scanner;
             struct stat buf;
             FILE *in;
     
             in = fopen( filename, "r" );
             stat( filename, &buf );
     
             yylex_init_extra( buf, &scanner );
             yyset_in( in, scanner );
             yylex( scanner );
             yylex_destroy( scanner );
     
             fclose( in );
        }
\end{verbatim}



Previous:Extra Data,
Up:Reentrant Detail

 \verb`yyscan_t` is defined as:
\begin{verbatim}
typedef void* yyscan_t;
\end{verbatim}


It is initialized by \verb`yylex_init()` to point to
an internal structure. You should never access this value
directly. In particular, you should never attempt to free it
(use \verb`yylex_destroy()` instead.)
\section{Functions and Macros Available in Reentrant C Scanners}


The following Functions are available in a reentrant scanner:


\begin{verbatim}
char *yyget_text ( yyscan_t scanner );
         int yyget_leng ( yyscan_t scanner );
         FILE *yyget_in ( yyscan_t scanner );
         FILE *yyget_out ( yyscan_t scanner );
         int yyget_lineno ( yyscan_t scanner );
         YY_EXTRA_TYPE yyget_extra ( yyscan_t scanner );
         int  yyget_debug ( yyscan_t scanner );
     
         void yyset_debug ( int flag, yyscan_t scanner );
         void yyset_in  ( FILE * in_str , yyscan_t scanner );
         void yyset_out  ( FILE * out_str , yyscan_t scanner );
         void yyset_lineno ( int line_number , yyscan_t scanner );
         void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t scanner );
\end{verbatim}


There are no “set” functions for yytext and yyleng. This is intentional.

The following Macro shortcuts are available in actions in a reentrant
scanner:
\begin{verbatim}
yytext
         yyleng
         yyin
         yyout
         yylineno
         yyextra
         yy_flex_debug
\end{verbatim}


In a reentrant C scanner, support for yylineno is always present
(i.e., you may access yylineno), but the value is never modified by \verb`flex` unless \verb`%option yylineno` is enabled. This is to allow
the user to maintain the line count independently of \verb`flex` .

The following functions and macros are made available when \verb`%option bison-bridge` (‘\verb`--bison-bridge`’) is specified:
\begin{verbatim}
YYSTYPE * yyget_lval ( yyscan_t scanner );
         void yyset_lval ( YYSTYPE * yylvalp , yyscan_t scanner );
         yylval
\end{verbatim}


The following functions and macros are made available
when \verb`%option bison-locations` (‘\verb`--bison-locations`’) is specified:
\begin{verbatim}
YYLTYPE *yyget_lloc ( yyscan_t scanner );
         void yyset_lloc ( YYLTYPE * yyllocp , yyscan_t scanner );
         yylloc
\end{verbatim}


Support for yylval assumes that \verb`YYSTYPE` is a valid type.  Support for
yylloc assumes that \verb`YYSLYPE` is a valid type.  Typically, these types are
generated by \verb`bison` , and are included in section 1 of the \verb`flex` input.
\chapter{Incompatibilities with Lex and Posix}


 \verb`flex` is a rewrite of the AT\&{}T Unixtool (the two
implementations do not share any code, though), with some extensions and
incompatibilities, both of which are of concern to those who wish to
write scanners acceptable to both implementations. \verb`flex` is fully
compliant with the POSIX \verb`lex` specification, except that when
using \verb`%pointer` (the default), a call to \verb`unput()` destroys
the contents of \verb`yytext` , which is counter to the POSIX
specification.  In this section we discuss all of the known areas of
incompatibility between \verb`flex` , AT\&{}T \verb`lex` , and the POSIX
specification. \verb`flex` 's ‘\verb`-l`’ option turns on maximum
compatibility with the original AT\&{}T \verb`lex` implementation, at the
cost of a major loss in the generated scanner's performance.  We note
below which incompatibilities can be overcome using the ‘\verb`-l`’
option. \verb`flex` is fully compatible with \verb`lex` with the
following exceptions:
\begin{itemize}
\item The undocumented \verb`lex` scanner internal variable \verb`yylineno` is
not supported unless ‘\verb`-l`’ or \verb`%option yylineno` is used.
\item  \verb`yylineno` should be maintained on a per-buffer basis, rather than
a per-scanner (single global variable) basis.
\item  \verb`yylineno` is not part of the POSIX specification.
\item The \verb`input()` routine is not redefinable, though it may be called
to read characters following whatever has been matched by a rule.  If \verb`input()` encounters an end-of-file the normal \verb`yywrap()` processing is done.  A “real” end-of-file is returned by \verb`input()` as \verb`EOF` .
\item Input is instead controlled by defining the \verb`YY_INPUT()` macro.
\item The \verb`flex` restriction that \verb`input()` cannot be redefined is
in accordance with the POSIX specification, which simply does not
specify any way of controlling the scanner's input other than by making
an initial assignment to.
\item The \verb`unput()` routine is not redefinable.  This restriction is in
accordance with POSIX.
\item  \verb`flex` scanners are not as reentrant as \verb`lex` scanners.  In
particular, if you have an interactive scanner and an interrupt handler
which long-jumps out of the scanner, and the scanner is subsequently
called again, you may get the following message:


\begin{verbatim}
fatal flex scanner internal error--end of buffer missed
\end{verbatim}


To reenter the scanner, first use:


\begin{verbatim}
yyrestart( yyin );
\end{verbatim}


Note that this call will throw away any buffered input; usually this
isn't a problem with an interactive scanner. SeeReentrant, for \verb`flex` 's reentrant API.
\item Also note that \verb`flex` C++ scanner classesreentrant, so if using C++ is an option for you, you should use
them instead.  SeeCxx, andReentrantfor details.
\item  \verb`output()` is not supported.  Output from themacro is
done to the file-pointer \verb`yyout` (default.
\item  \verb`output()` is not part of the POSIX specification.
\item  \verb`lex` does not support exclusive start conditions (\%{}x), though they
are in the POSIX specification.
\item When definitions are expanded, \verb`flex` encloses them in parentheses. 
With \verb`lex` , the following:


\begin{verbatim}
NAME    [A-Z][A-Z0-9]*
              %%
              foo{NAME}?      printf( "Found it\n" );
              %%
\end{verbatim}


will not match the string ‘\verb`foo`’ because when the macro is expanded
the rule is equivalent to ‘\verb`foo[A-Z][A-Z0-9]*?`’  and the precedence
is such that the ‘\verb`?`’ is associated with ‘\verb`[A-Z0-9]*`’.  With \verb`flex` , the rule will be expanded to ‘\verb`foo([A-Z][A-Z0-9]*)?`’
and so the string ‘\verb`foo`’ will match.
\item Note that if the definition begins with ‘\verb`^`’ or ends with ‘\verb`$`’
then it isexpanded with parentheses, to allow these
operators to appear in definitions without losing their special
meanings.  But the ‘\verb`<s>`’, ‘\verb`/`’, and \verb`<<EOF>>` operators
cannot be used in a \verb`flex` definition.
\item Using ‘\verb`-l`’ results in the \verb`lex` behavior of no parentheses
around the definition.
\item The POSIX specification is that the definition be enclosed in parentheses.
\item Some implementations of \verb`lex` allow a rule's action to begin on a
separate line, if the rule's pattern has trailing whitespace:


\begin{verbatim}
%%
              foo|bar<space here>
                { foobar_action();}
\end{verbatim}


 \verb`flex` does not support this feature.
\item The \verb`lex`  \verb`%r` (generate a Ratfor scanner) option is not
supported.  It is not part of the POSIX specification.
\item After a call to \verb`unput()` ,is undefined until the
next token is matched, unless the scanner was built using \verb`%array` . 
This is not the case with \verb`lex` or the POSIX specification.  The
‘\verb`-l`’ option does away with this incompatibility.
\item The precedence of the ‘\verb`{,}`’ (numeric range) operator is
different.  The AT\&{}T and POSIX specifications of \verb`lex` interpret ‘\verb`abc{1,3}`’ as match one, two,
or three occurrences of ‘\verb`abc`’”, whereas \verb`flex` interprets it
as “match ‘\verb`ab`’ followed by one, two, or three occurrences of
‘\verb`c`’”.  The ‘\verb`-l`’ and ‘\verb`--posix`’ options do away with this
incompatibility.
\item The precedence of the ‘\verb`^`’ operator is different. \verb`lex` interprets ‘\verb`^foo|bar`’ as “match either 'foo' at the beginning of a
line, or 'bar' anywhere”, whereas \verb`flex` interprets it as “match
either ‘\verb`foo`’ or ‘\verb`bar`’ if they come at the beginning of a
line”.  The latter is in agreement with the POSIX specification.
\item The special table-size declarations such as \verb`%a` supported by \verb`lex` are not required by \verb`flex` scanners.. \verb`flex` ignores them.
\item The name \verb`FLEX_SCANNER` is \verb`#define` 'd so scanners may be
written for use with either \verb`flex` or \verb`lex` .  Scanners also
include \verb`YY_FLEX_MAJOR_VERSION` , \verb`YY_FLEX_MINOR_VERSION` and \verb`YY_FLEX_SUBMINOR_VERSION` indicating which version of \verb`flex` generated the scanner. For
example, for the 2.5.22 release, these defines would be 2,  5 and 22
respectively. If the version of \verb`flex` being used is a beta
version, then the symbol \verb`FLEX_BETA` is defined.
\item The symbols ‘\verb`[[`’ and ‘\verb`]]`’ in the code sections of the input
may conflict with the m4 delimiters. SeeM4 Dependency.
\end{itemize}


The following \verb`flex` features are not included in \verb`lex` or the
POSIX specification:
\begin{itemize}
\item C++ scanners
\item \%{}option
\item start condition scopes
\item start condition stacks
\item interactive/non-interactive scanners
\item yy\_{}scan\_{}string() and friends
\item yyterminate()
\item yy\_{}set\_{}interactive()
\item yy\_{}set\_{}bol()
\item YY\_{}AT\_{}BOL()
   <<EOF>>
\item <*>
\item YY\_{}DECL
\item YY\_{}START
\item YY\_{}USER\_{}ACTION
\item YY\_{}USER\_{}INIT
\item \#{}line directives
\item \%{}\{{}\}{}'s around actions
\item reentrant C API
\item multiple actions on a line
\item almost all of the \verb`flex` command-line options
\end{itemize}


The feature “multiple actions on a line”
refers to the fact that with \verb`flex` you can put multiple actions on
the same line, separated with semi-colons, while with \verb`lex` , the
following:
\begin{verbatim}
foo    handle_foo(); ++num_foos_seen;
\end{verbatim}


is (rather surprisingly) truncated to
\begin{verbatim}
foo    handle_foo();
\end{verbatim}


 \verb`flex` does not truncate the action.  Actions that are not enclosed
in braces are simply terminated at the end of the line.
\chapter{Memory Management}


This chapter describes how flex handles dynamic memory, and how you can
override the default behavior.
\begin{itemize}
\item The Default Memory Management
\item Overriding The Default Memory Management
\item A Note About yytext And Memory
\end{itemize}

\section{The Default Memory Management}


Flex allocates dynamic memory during initialization, and once in a while from
within a call to yylex(). Initialization takes place during the first call to
yylex(). Thereafter, flex may reallocate more memory if it needs to enlarge a
buffer. As of version 2.5.9 Flex will clean up all memory when you call \verb`yylex_destroy` Seefaq-memory-leak.

Flex allocates dynamic memory for four purposes, listed belowFlex allocates memory for the character buffer used to perform pattern
matching.  Flex must read ahead from the input stream and store it in a large
character buffer.  This buffer is typically the largest chunk of dynamic memory
flex consumes. This buffer will grow if necessary, doubling the size each time. 
Flex frees this memory when you call yylex\_{}destroy().  The default size of this
buffer (16384 bytes) is almost always too large.  The ideal size for this
buffer is the length of the longest token expected, in bytes, plus a little more.  Flex will allocate a few
extra bytes for housekeeping. Currently, to override the size of the input buffer
you must \verb`#define YY_BUF_SIZE` to whatever number of bytes you want. We don't plan
to change this in the near future, but we reserve the right to do so if we ever add a more robust memory management
API.The size is  large enough to hold the same number of states as characters in the input buffer. If you override the size of the
input buffer (via \verb`YY_BUF_SIZE` ), then you automatically override the size of this buffer as well.Flex allocates memory for the start condition stack. This is the stack used
for pushing start states, i.e., with yy\_{}push\_{}state(). It will grow if
necessary.  Since the states are simply integers, this stack doesn't consume
much memory.  This stack is not present if \verb`%option stack` is not
specified.  You will rarely need to tune this buffer. The ideal size for this
stack is the maximum depth expected.  The memory for this stack is
automatically destroyed when you call yylex\_{}destroy(). Seeoption-stack.Flex allocates memory for each YY\_{}BUFFER\_{}STATE. The buffer state itself
is about 40 bytes, plus an additional large character buffer (described above.) 
The initial buffer state is created during initialization, and with each call
to yy\_{}create\_{}buffer(). You can't tune the size of this, but you can tune the
character buffer as described above. Any buffer state that you explicitly
create by calling yy\_{}create\_{}buffer() isdestroyed automatically. You
must call yy\_{}delete\_{}buffer() to free the memory. The exception to this rule is
that flex will delete the current buffer automatically when you call
yylex\_{}destroy(). If you delete the current buffer, be sure to set it to NULL. 
That way, flex will not try to delete the buffer a second time (possibly
crashing your program!) At the time of this writing, flex does not provide a
growable stack for the buffer states.  You have to manage that yourself. 
SeeMultiple Input Buffers.Flex allocates about 84 bytes for the reentrant scanner structure when
you call yylex\_{}init(). It is destroyed when the user calls yylex\_{}destroy().

1The
quantities given here are approximate, and may vary due to host architecture,
compiler configuration, or due to future enhancements to flex.
\section{Overriding The Default Memory Management}


Flex calls the functions \verb`yyalloc` , \verb`yyrealloc` , and \verb`yyfree` when it needs to allocate or free memory. By default, these functions are
wrappers around the standard C functions, \verb`malloc` , \verb`realloc` , and \verb`free` , respectively. You can override the default implementations by telling
flex that you will provide your own implementations.

To override the default implementations, you must do two things:
\begin{enumerate}
\item Suppress the default implementations by specifying one or more of the
following options:
\begin{itemize}
\item  \verb`%option noyyalloc` 
\item  \verb`%option noyyrealloc` 
\item  \verb`%option noyyfree` .
\end{itemize}

\item Provide your own implementation of the following functions:
\begin{verbatim}
// For a non-reentrant scanner
          void * yyalloc (size_t bytes);
          void * yyrealloc (void * ptr, size_t bytes);
          void   yyfree (void * ptr);
          
          // For a reentrant scanner
          void * yyalloc (size_t bytes, void * yyscanner);
          void * yyrealloc (void * ptr, size_t bytes, void * yyscanner);
          void   yyfree (void * ptr, void * yyscanner);
\end{verbatim}

\end{enumerate}


In the following example, we will override all three memory routines. We assume
that there is a custom allocator with garbage collection. In order to make this
example interesting, we will use a reentrant scanner, passing a pointer to the
custom allocator through \verb`yyextra` .


\begin{verbatim}
%{
     #include "some_allocator.h"
     %}
     
     /* Suppress the default implementations. */
     %option noyyalloc noyyrealloc noyyfree
     %option reentrant
     
     /* Initialize the allocator. */
     #define YY_EXTRA_TYPE  struct allocator*
     #define YY_USER_INIT  yyextra = allocator_create();
     
     %%
     .|\n   ;
     %%
     
     /* Provide our own implementations. */
     void * yyalloc (size_t bytes, void* yyscanner) {
         return allocator_alloc (yyextra, bytes);
     }
     
     void * yyrealloc (void * ptr, size_t bytes, void* yyscanner) {
         return allocator_realloc (yyextra, bytes);
     }
     
     void yyfree (void * ptr, void * yyscanner) {      
         /* Do nothing -- we leave it to the garbage collector. */
     }
\end{verbatim}


1It
is not necessary to override all (or any) of the memory management routines. 
You may, for example, override \verb`yyrealloc` , but not \verb`yyfree` or \verb`yyalloc` .
\section{A Note About yytext And Memory}


When flex finds a match, \verb`yytext` points to the first character of the
match in the input buffer. The string itself is part of the input buffer, and
isallocated separately. The value of yytext will be overwritten the next
time yylex() is called. In short, the value of yytext is only valid from within
the matched rule's action.

Often, you want the value of yytext to persist for later processing, i.e., by a
parser with non-zero lookahead. In order to preserve yytext, you will have to
copy it with strdup() or a similar function. But this introduces some headache
because your parser is now responsible for freeing the copy of yytext. If you
use a yacc or bison parser, (commonly used with flex), you will discover that
the error recovery mechanisms can cause memory to be leaked.

To prevent memory leaks from strdup'd yytext, you will have to track the memory
somehow. Our experience has shown that a garbage collection mechanism or a
pooled memory mechanism will save you a lot of grief when writing parsers.
\chapter{Serialized Tables}


A \verb`flex` scanner has the ability to save the DFA tables to a file, and
load them at runtime when needed.  The motivation for this feature is to reduce
the runtime memory footprint.  Traditionally, these tables have been compiled into
the scanner as C arrays, and are sometimes quite large.  Since the tables are
compiled into the scanner, the memory used by the tables can never be freed. 
This is a waste of memory, especially if an application uses several scanners,
but none of them at the same time.

The serialization feature allows the tables to be loaded at runtime, before
scanning begins. The tables may be discarded when scanning is finished.
\begin{itemize}
\item Creating Serialized Tables
\item Loading and Unloading Serialized Tables
\item Tables File Format
\end{itemize}

\section{Creating Serialized Tables}


You may create a scanner with serialized tables by specifying:
\begin{verbatim}
%option tables-file=FILE
     or
         --tables-file=FILE
\end{verbatim}


These options instruct flex to save the DFA tables to the file. The tables
willbe embedded in the generated scanner. The scanner will not
function on its own. The scanner will be dependent upon the serialized tables. You must
load the tables from this file at runtime before you can scan anything.

If you do not specify a filename to \verb`--tables-file` , the tables will be
saved to, where ‘\verb`yy`’ is the appropriate prefix.

If your project uses several different scanners, you can concatenate the
serialized tables into one file, and flex will find the correct set of tables,
using the scanner prefix as part of the lookup key. An example follows:


\begin{verbatim}
$ flex --tables-file --prefix=cpp cpp.l
     $ flex --tables-file --prefix=c   c.l
     $ cat lex.cpp.tables lex.c.tables  >  all.tables
\end{verbatim}


The above example created two scanners, ‘\verb`cpp`’, and ‘\verb`c`’. Since we did
not specify a filename, the tables were serialized toand, respectively. Then, we concatenated the two files
together into, which we will distribute with our project. At
runtime, we will open the file and tell flex to load the tables from it.  Flex
will find the correct tables automatically. (See next section).
\section{Loading and Unloading Serialized Tables}


If you've built your scanner with \verb`%option tables-file` , then you must
load the scanner tables at runtime. This can be accomplished with the following
function:

Locates scanner tables in the stream pointed to byand loads them. 
Memory for the tables is allocated via \verb`yyalloc` .  You must call this
function before the first call to \verb`yylex` . The argumentonly appears in the reentrant scanner. 
This function returns ‘\verb`0`’ (zero) on success, or non-zero on error.

The loaded tables areautomatically destroyed (unloaded) when you
call \verb`yylex_destroy` . The reason is that you may create several scanners
of the same type (in a reentrant scanner), each of which needs access to these
tables.  To avoid a nasty memory leak, you must call the following function:

Unloads the scanner tables. The tables must be loaded again before you can scan
any more data.  The argumentonly appears in the reentrant
scanner.  This function returns ‘\verb`0`’ (zero) on success, or non-zero on
error.

 \verb`yytables_fload`  \verb`yytables_destroy` You must ensure that these functions are called exactly once (for
each scanner type) in a threaded program, before any thread calls \verb`yylex` . 
After the tables are loaded, they are never written to, and no thread
protection is required thereafter – until you destroy them.
\section{Tables File Format}


This section defines the file format of serialized \verb`flex` tables.

The tables format allows for one or more sets of tables to be
specified, where each set corresponds to a given scanner. Scanners are
indexed by name, as described below. The file format is as follows:
\begin{verbatim}
TABLE SET 1
                     +-------------------------------+
             Header  | uint32          th_magic;     |
                     | uint32          th_hsize;     |
                     | uint32          th_ssize;     |
                     | uint16          th_flags;     |
                     | char            th_version[]; |
                     | char            th_name[];    |
                     | uint8           th_pad64[];   |
                     +-------------------------------+
             Table 1 | uint16          td_id;        |
                     | uint16          td_flags;     |
                     | uint32          td_hilen;     |
                     | uint32          td_lolen;     |
                     | void            td_data[];    |
                     | uint8           td_pad64[];   |
                     +-------------------------------+
             Table 2 |                               |
                .    .                               .
                .    .                               .
                .    .                               .
                .    .                               .
             Table n |                               |
                     +-------------------------------+
                      TABLE SET 2
                           .
                           .
                           .
                      TABLE SET N
\end{verbatim}


The above diagram shows that a complete set of tables consists of a header
followed by multiple individual tables. Furthermore, multiple complete sets may
be present in the same file, each set with its own header and tables. The sets
are contiguous in the file. The only way to know if another set follows is to
check the next four bytes for the magic number (or check for EOF). The header
and tables sections are padded to 64-bit boundaries. Below we describe each
field in detail. This format does not specify how the scanner will expand the
given data, i.e., data may be serialized as int8, but expanded to an int32
array at runtime. This is to reduce the size of the serialized data where
possible.  Remember,.

Fields of a table header: \verb`th_magic` Magic number, always 0xF13C57B1. \verb`th_hsize` Size of this entire header, in bytes, including all fields plus any padding. \verb`th_ssize` Size of this entire set, in bytes, including the header, all tables, plus
any padding. \verb`th_flags` Bit flags for this table set. Currently unused. \verb`th_version[]` Flex version in NULL-terminated string format. e.g., ‘\verb`2.5.13a`’. This is
the version of flex that was used to create the serialized tables. \verb`th_name[]` Contains the name of this table set. The default is ‘\verb`yytables`’,
and is prefixed accordingly, e.g., ‘\verb`footables`’. Must be NULL-terminated. \verb`th_pad64[]` Zero or more NULL bytes, padding the entire header to the next 64-bit boundary
as calculated from the beginning of the header.

Fields of a table: \verb`td_id` Specifies the table identifier. Possible values are: \verb`YYTD_ID_ACCEPT (0x01)`  \verb`yy_accept`  \verb`YYTD_ID_BASE   (0x02)`  \verb`yy_base`  \verb`YYTD_ID_CHK    (0x03)`  \verb`yy_chk`  \verb`YYTD_ID_DEF    (0x04)`  \verb`yy_def`  \verb`YYTD_ID_EC     (0x05)`  \verb`yy_ec`  \verb`YYTD_ID_META   (0x06)`  \verb`yy_meta`  \verb`YYTD_ID_NUL_TRANS (0x07)`  \verb`yy_NUL_trans`  \verb`YYTD_ID_NXT (0x08)`  \verb`yy_nxt` . This array may be two dimensional. See the \verb`td_hilen` field below. \verb`YYTD_ID_RULE_CAN_MATCH_EOL (0x09)`  \verb`yy_rule_can_match_eol`  \verb`YYTD_ID_START_STATE_LIST (0x0A)`  \verb`yy_start_state_list` . This array is handled specially because it is an
array of pointers to structs. See the \verb`td_flags` field below. \verb`YYTD_ID_TRANSITION (0x0B)`  \verb`yy_transition` . This array is handled specially because it is an array of
structs. See the \verb`td_lolen` field below. \verb`YYTD_ID_ACCLIST (0x0C)`  \verb`yy_acclist`  \verb`td_flags` Bit flags describing how to interpret the data in \verb`td_data` . 
The data arrays are one-dimensional by default, but may be
two dimensional as specified in the \verb`td_hilen` field. \verb`YYTD_DATA8 (0x01)` The data is serialized as an array of type int8. \verb`YYTD_DATA16 (0x02)` The data is serialized as an array of type int16. \verb`YYTD_DATA32 (0x04)` The data is serialized as an array of type int32. \verb`YYTD_PTRANS (0x08)` The data is a list of indexes of entries in the expanded \verb`yy_transition` array.  Each index should be expanded to a pointer to the corresponding entry
in the \verb`yy_transition` array. We count on the fact that the \verb`yy_transition` array has already been seen. \verb`YYTD_STRUCT (0x10)` The data is a list of yy\_{}trans\_{}info structs, each of which consists of
two integers. There is no padding between struct elements or between structs. 
The type of each member is determined by the \verb`YYTD_DATA*` bits. \verb`td_hilen` If \verb`td_hilen` is non-zero, then the data is a two-dimensional array. 
Otherwise, the data is a one-dimensional array. \verb`td_hilen` contains the
number of elements in the higher dimensional array, and \verb`td_lolen` contains
the number of elements in the lowest dimension.

Conceptually, \verb`td_data` is either \verb`sometype td_data[td_lolen]` , or \verb`sometype td_data[td_hilen][td_lolen]` , where \verb`sometype` is specified
by the \verb`td_flags` field.  It is possible for both \verb`td_lolen` and \verb`td_hilen` to be zero, in which case \verb`td_data` is a zero length
array, and no data is loaded, i.e., this table is simply skipped. Flex does not
currently generate tables of zero length. \verb`td_lolen` Specifies the number of elements in the lowest dimension array. If this is
a one-dimensional array, then it is simply the number of elements in this array. 
The element size is determined by the \verb`td_flags` field. \verb`td_data[]` The table data. This array may be a one- or two-dimensional array, of type \verb`int8` , \verb`int16` , \verb`int32` , \verb`struct yy_trans_info` , or \verb`struct yy_trans_info*` ,  depending upon the values in the \verb`td_flags` , \verb`td_hilen` , and \verb`td_lolen` fields. \verb`td_pad64[]` Zero or more NULL bytes, padding the entire table to the next 64-bit boundary as
calculated from the beginning of this table.
\chapter{Diagnostics}


The following is a list of \verb`flex` diagnostic messages:
\begin{itemize}
\item ‘\verb`warning, rule cannot be matched`’ indicates that the given rule
cannot be matched because it follows other rules that will always match
the same text as it.  For example, in the following ‘\verb`foo`’ cannot be
matched because it comes after an identifier “catch-all” rule:


\begin{verbatim}
[a-z]+    got_identifier();
              foo       got_foo();
\end{verbatim}


Using \verb`REJECT` in a scanner suppresses this warning.
\item ‘\verb`warning, -s option given but default rule can be matched`’ means
that it is possible (perhaps only in a particular start condition) that
the default rule (match any single character) is the only one that will
match a particular input.  Since ‘\verb`-s`’ was given, presumably this is
not intended.
\item  \verb`reject_used_but_not_detected undefined` or \verb`yymore_used_but_not_detected undefined` . These errors can occur
at compile time.  They indicate that the scanner uses \verb`REJECT` or \verb`yymore()` but that \verb`flex` failed to notice the fact, meaning
that \verb`flex` scanned the first two sections looking for occurrences
of these actions and failed to find any, but somehow you snuck some in
(via a \#{}include file, for example).  Use \verb`%option reject` or \verb`%option yymore` to indicate to \verb`flex` that you really do use
these features.
\item ‘\verb`flex scanner jammed`’. a scanner compiled with
‘\verb`-s`’ has encountered an input string which wasn't matched by any of
its rules.  This error can also occur due to internal problems.
\item ‘\verb`token too large, exceeds YYLMAX`’. your scanner uses \verb`%array` and one of its rules matched a string longer than the \verb`YYLMAX` constant (8K bytes by default).  You can increase the value by
\#{}define'ing \verb`YYLMAX` in the definitions section of your \verb`flex` input.
\item ‘\verb`scanner requires -8 flag to use the character 'x'`’. Your scanner
specification includes recognizing the 8-bit character ‘\verb`'x'`’ and
you did not specify the -8 flag, and your scanner defaulted to 7-bit
because you used the ‘\verb`-Cf`’ or ‘\verb`-CF`’ table compression options. 
See the discussion of the ‘\verb`-7`’ flag,Scanner Options, for
details.
\item ‘\verb`flex scanner push-back overflow`’. you used \verb`unput()` to push
back so much text that the scanner's buffer could not hold both the
pushed-back text and the current token in \verb`yytext` .  Ideally the
scanner should dynamically resize the buffer in this case, but at
present it does not.
\item ‘\verb`input buffer overflow, can't enlarge buffer because scanner uses REJECT`’.  the scanner was working on matching an extremely large token
and needed to expand the input buffer.  This doesn't work with scanners
that use \verb`REJECT` .
\item ‘\verb`fatal flex scanner internal error--end of buffer missed`’. This can
occur in a scanner which is reentered after a long-jump has jumped out
(or over) the scanner's activation frame.  Before reentering the
scanner, use:
\begin{verbatim}
yyrestart( yyin );
\end{verbatim}


or, as noted above, switch to using the C++ scanner class.
\item ‘\verb`too many start conditions in <> construct!`’  you listed more start
conditions in a <> construct than exist (so you must have listed at
least one of them twice).
\end{itemize}

\chapter{Limitations}


Some trailing context patterns cannot be properly matched and generate
warning messages (‘\verb`dangerous trailing context`’).  These are
patterns where the ending of the first part of the rule matches the
beginning of the second part, such as ‘\verb`zx*/xy*`’, where the 'x*'
matches the 'x' at the beginning of the trailing context.  (Note that
the POSIX draft states that the text matched by such patterns is
undefined.)  For some trailing context rules, parts which are actually
fixed-length are not recognized as such, leading to the abovementioned
performance loss.  In particular, parts using ‘\verb`|`’ or ‘\verb`{n}`’
(such as ‘\verb`foo{3}`’) are always considered variable-length. 
Combining trailing context with the special ‘\verb`|`’ action can result
intrailing context being turned into the more expensivetrailing context.  For example, in the following:


\begin{verbatim}
%%
         abc      |
         xyz/def
\end{verbatim}


Use of \verb`unput()` invalidates yytext and yyleng, unless the \verb`%array` directive or the ‘\verb`-l`’ option has been used. 
Pattern-matching of \verb`NUL` s is substantially slower than matching
other characters.  Dynamic resizing of the input buffer is slow, as it
entails rescanning all the text matched so far by the current (generally
huge) token.  Due to both buffering of input and read-ahead, you cannot
intermix calls toroutines, such as,,
with \verb`flex` rules and expect it to work.  Call \verb`input()` instead.  The total table entries listed by the ‘\verb`-v`’ flag excludes
the number of table entries needed to determine what rule has been
matched.  The number of entries is equal to the number of DFA states if
the scanner does not use \verb`REJECT` , and somewhat greater than the
number of states if it does. \verb`REJECT` cannot be used with the
‘\verb`-f`’ or ‘\verb`-F`’ options.

The \verb`flex` internal algorithms need documentation.
\chapter{Additional Reading}


You may wish to read more about the following programs:
\begin{itemize}
\item lex
\item yacc
\item sed
\item awk
\end{itemize}


The following books may contain material of interest:

John Levine, Tony Mason, and Doug Brown,,
O'Reilly and Associates.  Be sure to get the 2nd edition.

M. E. Lesk and E. Schmidt,

Alfred Aho, Ravi Sethi and Jeffrey Ullman,, Addison-Wesley (1986).  Describes the
pattern-matching techniques used by \verb`flex` (deterministic finite
automata).

\backmatter

\chapter{FAQ}


From time to time, the \verb`flex` maintainer receives certain
questions. Rather than repeat answers to well-understood problems, we
publish them here.
\begin{itemize}
\item When was flex born?
\item How do I expand backslash-escape sequences in C-style quoted strings?
\item Why do flex scanners call fileno if it is not ANSI compatible?
\item Does flex support recursive pattern definitions?
\item How do I skip huge chunks of input (tens of megabytes) while using flex?
\item Flex is not matching my patterns in the same order that I defined them.
\item My actions are executing out of order or sometimes not at all.
\item How can I have multiple input sources feed into the same scanner at the same time?
\item Can I build nested parsers that work with the same input file?
\item How can I match text only at the end of a file?
\item How can I make REJECT cascade across start condition boundaries?
\item Why cant I use fast or full tables with interactive mode?
\item How much faster is -F or -f than -C?
\item If I have a simple grammar cant I just parse it with flex?
\item Why doesn't yyrestart() set the start state back to INITIAL?
\item How can I match C-style comments?
\item The period isn't working the way I expected.
\item Can I get the flex manual in another format?
\item Does there exist a "faster" NDFA->DFA algorithm?
\item How does flex compile the DFA so quickly?
\item How can I use more than 8192 rules?
\item How do I abandon a file in the middle of a scan and switch to a new file?
\item How do I execute code only during initialization (only before the first scan)?
\item How do I execute code at termination?
\item Where else can I find help?
\item Can I include comments in the "rules" section of the file?
\item I get an error about undefined yywrap().
\item How can I change the matching pattern at run time?
\item How can I expand macros in the input?
\item How can I build a two-pass scanner?
\item How do I match any string not matched in the preceding rules?
\item I am trying to port code from AT\&{}T lex that uses yysptr and yysbuf.
\item Is there a way to make flex treat NULL like a regular character?
\item Whenever flex can not match the input it says "flex scanner jammed".
\item Why doesn't flex have non-greedy operators like perl does?
\item Memory leak - 16386 bytes allocated by malloc.
\item How do I track the byte offset for lseek()?
\item How do I use my own I/O classes in a C++ scanner?
\item How do I skip as many chars as possible?
\item deleteme00
\item Are certain equivalent patterns faster than others?
\item Is backing up a big deal?
\item Can I fake multi-byte character support?
\item deleteme01
\item Can you discuss some flex internals?
\item unput() messes up yy\_{}at\_{}bol
\item The | operator is not doing what I want
\item Why can't flex understand this variable trailing context pattern?
\item The \^{} operator isn't working
\item Trailing context is getting confused with trailing optional patterns
\item Is flex GNU or not?
\item ERASEME53
\item I need to scan if-then-else blocks and while loops
\item ERASEME55
\item ERASEME56
\item ERASEME57
\item Is there a repository for flex scanners?
\item How can I conditionally compile or preprocess my flex input file?
\item Where can I find grammars for lex and yacc?
\item I get an end-of-buffer message for each character scanned.
\item unnamed-faq-62
\item unnamed-faq-63
\item unnamed-faq-64
\item unnamed-faq-65
\item unnamed-faq-66
\item unnamed-faq-67
\item unnamed-faq-68
\item unnamed-faq-69
\item unnamed-faq-70
\item unnamed-faq-71
\item unnamed-faq-72
\item unnamed-faq-73
\item unnamed-faq-74
\item unnamed-faq-75
\item unnamed-faq-76
\item unnamed-faq-77
\item unnamed-faq-78
\item unnamed-faq-79
\item unnamed-faq-80
\item unnamed-faq-81
\item unnamed-faq-82
\item unnamed-faq-83
\item unnamed-faq-84
\item unnamed-faq-85
\item unnamed-faq-86
\item unnamed-faq-87
\item unnamed-faq-88
\item unnamed-faq-90
\item unnamed-faq-91
\item unnamed-faq-92
\item unnamed-faq-93
\item unnamed-faq-94
\item unnamed-faq-95
\item unnamed-faq-96
\item unnamed-faq-97
\item unnamed-faq-98
\item unnamed-faq-99
\item unnamed-faq-100
\item unnamed-faq-101
\item What is the difference between YYLEX\_{}PARAM and YY\_{}DECL?
\item Why do I get "conflicting types for yylex" error?
\item How do I access the values set in a Flex action from within a Bison action?
\end{itemize}

\section{When was flex born?}


Vern Paxson took over
thelex project from Jef Poskanzer in 1982.  At that point it
was written in Ratfor.  Around 1987 or so, Paxson translated it into C, and
a legend was born :-).
\section{How do I expand backslash-escape sequences in C-style quoted strings?}


A key point when scanning quoted strings is that you cannot (easily) write
a single rule that will precisely match the string if you allow things
like embedded escape sequences and newlines.  If you try to match strings
with a single rule then you'll wind up having to rescan the string anyway
to find any escape sequences.

Instead you can use exclusive start conditions and a set of rules, one for
matching non-escaped text, one for matching a single escape, one for
matching an embedded newline, and one for recognizing the end of the
string.  Each of these rules is then faced with the question of where to
put its intermediary results.  The best solution is for the rules to
append their local value of \verb`yytext` to the end of a “string literal”
buffer.  A rule like the escape-matcher will append to the buffer the
meaning of the escape sequence rather than the literal text in \verb`yytext` . 
In this way, \verb`yytext` does not need to be modified at all.
\section{Why do flex scanners call fileno if it is not ANSI compatible?}


Flex scanners call \verb`fileno()` in order to get the file descriptor
corresponding to \verb`yyin` . The file descriptor may be passed to \verb`isatty()` or \verb`read()` , depending upon which \verb`%options` you specified. 
If your system does not have \verb`fileno()` support, to get rid of the \verb`read()` call, do not specify \verb`%option read` . To get rid of the \verb`isatty()` call, you must specify one of \verb`%option always-interactive` or \verb`%option never-interactive` .
\section{Does flex support recursive pattern definitions?}


e.g.,
\begin{verbatim}
%%
     block   "{"({block}|{statement})*"}"
\end{verbatim}


No. You cannot have recursive definitions.  The pattern-matching power of
regular expressions in general (and therefore flex scanners, too) is
limited.  In particular, regular expressions cannot “balance” parentheses
to an arbitrary degree.  For example, it's impossible to write a regular
expression that matches all strings containing the same number of '\{{}'s
as '\}{}'s.  For more powerful pattern matching, you need a parser, such
as.
\section{How do I skip huge chunks of input (tens of megabytes) while using flex?}


Use \verb`fseek()` (or \verb`lseek()` ) to position yyin, then call \verb`yyrestart()` .
\section{Flex is not matching my patterns in the same order that I defined them.}


 \verb`flex` picks the
rule that matches the most text (i.e., the longest possible input string). 
This is because \verb`flex` uses an entirely different matching technique
(“deterministic finite automata”) that actually does all of the matching
simultaneously, in parallel.  (Seems impossible, but it's actually a fairly
simple technique once you understand the principles.)

A side-effect of this parallel matching is that when the input matches more
than one rule, \verb`flex` scanners pick the rule that matched thetext. This
is explained further in the manual, in the section SeeMatching.

If you want \verb`flex` to choose a shorter match, then you can work around this
behavior by expanding your short
rule to match more text, then put back the extra:
\begin{verbatim}
data_.*        yyless( 5 ); BEGIN BLOCKIDSTATE;
\end{verbatim}


Another fix would be to make the second rule active only during the \verb`<BLOCKIDSTATE>` start condition, and make that start condition exclusive
by declaring it with \verb`%x` instead of \verb`%s` .

A final fix is to change the input language so that the ambiguity for
‘\verb`data_`’ is removed, by adding characters to it that don't match the
identifier rule, or by removing characters (such as ‘\verb`_`’) from the
identifier rule so it no longer matches ‘\verb`data_`’.  (Of course, you might
also not have the option of changing the input language.)
\section{My actions are executing out of order or sometimes not at all.}


Most likely, you have (in error) placed the opening ‘\verb`{`’ of the action
block on a different line than the rule, e.g.,
\begin{verbatim}
^(foo|bar)
     {  <<<--- WRONG!
     
     }
\end{verbatim}


 \verb`flex` requires that the opening ‘\verb`{`’ of an action associated with a rule
begin on the same line as does the rule.  You need instead to write your rules
as follows:
\begin{verbatim}
^(foo|bar)   {  // CORRECT!
     
     }
\end{verbatim}

\section{How can I have multiple input sources feed into the same scanner at the same time?}


If
\begin{itemize}
\item your scanner is free of backtracking (verified using \verb`flex` 's ‘\verb`-b`’ flag),
\item AND you run your scanner interactively (‘\verb`-I`’ option; default unless using special table
compression options),
\item AND you feed it one character at a time by redefining \verb`YY_INPUT` to do so,
\end{itemize}


then every time it matches a token, it will have exhausted its input
buffer (because the scanner is free of backtracking).  This means you
can safely use \verb`select()` at the point and only call \verb`yylex()` for another
token if \verb`select()` indicates there's data available.

That is, move the \verb`select()` out from the input function to a point where
it determines whether \verb`yylex()` gets called for the next token.

With this approach, you will still have problems if your input can arrive
piecemeal; \verb`select()` could inform you that the beginning of a token is
available, you call \verb`yylex()` to get it, but it winds up blocking waiting
for the later characters in the token.

Here's another way:  Move your input multiplexing inside of \verb`YY_INPUT` .  That
is, whenever \verb`YY_INPUT` is called, it \verb`select()` 's to see where input is
available.  If input is available for the scanner, it reads and returns the
next byte.  If input is available from another source, it calls whatever
function is responsible for reading from that source.  (If no input is
available, it blocks until some input is available.)  I've used this technique in an
interpreter I wrote that both reads keyboard input using a \verb`flex` scanner and
IPC traffic from sockets, and it works fine.
\section{Can I build nested parsers that work with the same input file?}


This is not going to work without some additional effort.  The reason is
that \verb`flex` block-buffers the input it reads from \verb`yyin` .  This means that the
“outermost” \verb`yylex()` , when called, will automatically slurp up the first 8K
of input available on yyin, and subsequent calls to other \verb`yylex()` 's won't
see that input.  You might be tempted to work around this problem by
redefining \verb`YY_INPUT` to only return a small amount of text, but it turns out
that that approach is quite difficult.  Instead, the best solution is to
combine all of your scanners into one large scanner, using a different
exclusive start condition for each.
\section{How can I match text only at the end of a file?}


There is no way to write a rule which is “match this text, but only if
it comes at the end of the file”.  You can fake it, though, if you happen
to have a character lying around that you don't allow in your input. 
Then you redefine \verb`YY_INPUT` to call your own routine which, if it sees
an ‘\verb`EOF`’, returns the magic character first (and remembers to return a
real \verb`EOF` next time it's called).  Then you could write:
\begin{verbatim}
<COMMENT>(.|\n)*{EOF_CHAR}    /* saw comment at EOF */
\end{verbatim}

\section{How can I make REJECT cascade across start condition boundaries?}


You can do this as follows.  Suppose you have a start condition ‘\verb`A`’, and
after exhausting all of the possible matches in ‘\verb`<A>`’, you want to try
matches in ‘\verb`<INITIAL>`’.  Then you could use the following:
\begin{verbatim}
%x A
     %%
     <A>rule_that_is_long    ...; REJECT;
     <A>rule                 ...; REJECT; /* shorter rule */
     <A>etc.
     ...
     <A>.|\n  {
     /* Shortest and last rule in <A>, so
     * cascaded REJECTs will eventually
     * wind up matching this rule.  We want
     * to now switch to the initial state
     * and try matching from there instead.
     */
     yyless(0);    /* put back matched text */
     BEGIN(INITIAL);
     }
\end{verbatim}

\section{Why can't I use fast or full tables with interactive mode?}


One of the assumptions
flex makes is that interactive applications are inherently slow (they're
waiting on a human after all). 
It has to do with how the scanner detects that it must be finished scanning
a token.  For interactive scanners, after scanning each character the current
state is looked up in a table (essentially) to see whether there's a chance
of another input character possibly extending the length of the match.  If
not, the scanner halts.  For non-interactive scanners, the end-of-token test
is much simpler, basically a compare with 0, so no memory bus cycles.  Since
the test occurs in the innermost scanning loop, one would like to make it go
as fast as possible.

Still, it seems reasonable to allow the user to choose to trade off a bit
of performance in this area to gain the corresponding flexibility.  There
might be another reason, though, why fast scanners don't support the
interactive option.
\section{How much faster is -F or -f than -C?}


Much faster (factor of 2-3).
\section{If I have a simple grammar can't I just parse it with flex?}


Is your grammar recursive? That's almost always a sign that you're
better off using a parser/scanner rather than just trying to use a scanner
alone.
\section{Why doesn't yyrestart() set the start state back to INITIAL?}


There are two reasons.  The first is that there might
be programs that rely on the start state not changing across file changes. 
The second is that beginning with \verb`flex` version 2.4, use of \verb`yyrestart()` is no longer required,
so fixing the problem there doesn't solve the more general problem.
\section{How can I match C-style comments?}


You might be tempted to try something like this:
\begin{verbatim}
"/*".*"*/"       // WRONG!
\end{verbatim}


or, worse, this:
\begin{verbatim}
"/*"(.|\n)"*/"   // WRONG!
\end{verbatim}


The above rules will eat too much input, and blow up on things like:
\begin{verbatim}
/* a comment */ do_my_thing( "oops */" );
\end{verbatim}


Here is one way which allows you to track line information:
\begin{verbatim}
<INITIAL>{
     "/*"              BEGIN(IN_COMMENT);
     }
     <IN_COMMENT>{
     "*/"      BEGIN(INITIAL);
     [^*\n]+   // eat comment in chunks
     "*"       // eat the lone star
     \n        yylineno++;
     }
\end{verbatim}

\section{The '.' isn't working the way I expected.}


Here are some tips for using ‘\verb`.`’:
\begin{itemize}
\item A common mistake is to place the grouping parenthesis AFTER an operator, when
you really meant to place the parenthesis BEFORE the operator, e.g., you
probably want this \verb`(foo|bar)+` and NOT this \verb`(foo|bar+)` .

The first pattern matches the words ‘\verb`foo`’ or ‘\verb`bar`’ any number of
times, e.g., it matches the text ‘\verb`barfoofoobarfoo`’. The
second pattern matches a single instance of \verb`foo` or a single instance of \verb`bar` followed by one or more ‘\verb`r`’s, e.g., it matches the text \verb`barrrr` .
\item A ‘\verb`.`’ inside ‘\verb`[]`’'s just means a literal‘\verb`.`’ (period),
and NOT “any character except newline”.
\item Remember that ‘\verb`.`’ matches any character EXCEPT ‘\verb`\n`’ (and ‘\verb`EOF`’). 
If you really want to match ANY character, including newlines, then use \verb`(.|\n)` Beware that the regex \verb`(.|\n)+` will match your entire input!
\item Finally, if you want to match a literal ‘\verb`.`’ (a period), then use ‘\verb`[.]`’ or ‘\verb`"."`’
\end{itemize}

\section{Can I get the flex manual in another format?}


The \verb`flex` source distribution  includes a texinfo manual. You are
free to convert that texinfo into whatever format you desire. The \verb`texinfo` package includes tools for conversion to a number of formats.
\section{Does there exist a "faster" NDFA->DFA algorithm?}


There's no way around the potential exponential running time - it
can take you exponential time just to enumerate all of the DFA states. 
In practice, though, the running time is closer to linear, or sometimes
quadratic.
\section{How does flex compile the DFA so quickly?}


There are two big speed wins that \verb`flex` uses:
\begin{enumerate}
\item It analyzes the input rules to construct equivalence classes for those
characters that always make the same transitions.  It then rewrites the NFA
using equivalence classes for transitions instead of characters.  This cuts
down the NFA->DFA computation time dramatically, to the point where, for
uncompressed DFA tables, the DFA generation is often I/O bound in writing out
the tables.
\item It maintains hash values for previously computed DFA states, so testing
whether a newly constructed DFA state is equivalent to a previously constructed
state can be done very quickly, by first comparing hash values.
\end{enumerate}

\section{How can I use more than 8192 rules?}


 \verb`Flex` is compiled with an upper limit of 8192 rules per scanner. 
If you need more than 8192 rules in your scanner, you'll have to recompile \verb`flex` with the following changes in:
\begin{verbatim}
<    #define YY_TRAILING_MASK 0x2000
     <    #define YY_TRAILING_HEAD_MASK 0x4000
     --
     >    #define YY_TRAILING_MASK 0x20000000
     >    #define YY_TRAILING_HEAD_MASK 0x40000000
\end{verbatim}


This should work okay as long as your C compiler uses 32 bit integers. 
But you might want to think about whether using such a huge number of rules
is the best way to solve your problem.

The following may also be relevant:

With luck, you should be able to increase the definitions in flexdef.h for:
\begin{verbatim}
#define JAMSTATE -32766 /* marks a reference to the state that always jams */
     #define MAXIMUM_MNS 31999
     #define BAD_SUBSCRIPT -32767
\end{verbatim}


recompile everything, and it'll all work.  Flex only has these 16-bit-like
values built into it because a long time ago it was developed on a machine
with 16-bit ints.  I've given this advice to others in the past but haven't
heard back from them whether it worked okay or not...
\section{How do I abandon a file in the middle of a scan and switch to a new file?}


Just call \verb`yyrestart(newfile)` . Be sure to reset the start state if you want a
“fresh start, since \verb`yyrestart` does NOT reset the start state back to \verb`INITIAL` .
\section{How do I execute code only during initialization (only before the first scan)?}


You can specify an initial action by defining the macro \verb`YY_USER_INIT` (though
note that \verb`yyout` may not be available at the time this macro is executed).  Or you
can add to the beginning of your rules section:
\begin{verbatim}
%%
         /* Must be indented! */
         static int did_init = 0;
     
         if ( ! did_init ){
     do_my_init();
             did_init = 1;
         }
\end{verbatim}

\section{How do I execute code at termination?}


You can specify an action for the \verb`<<EOF>>` rule.
\section{Where else can I find help?}


You can find the flex homepage on the web athttp://flex.sourceforge.net/. See that page for details about flex
mailing lists as well.
\section{Can I include comments in the "rules" section of the file?}


Yes, just about anywhere you want to. See the manual for the specific syntax.
\section{I get an error about undefined yywrap().}


You must supply a \verb`yywrap()` function of your own, or link to(which provides one), or use
\begin{verbatim}
%option noyywrap
\end{verbatim}


in your source to say you don't want a \verb`yywrap()` function.
\section{How can I change the matching pattern at run time?}


You can't, it's compiled into a static table when flex builds the scanner.
\section{How can I expand macros in the input?}


The best way to approach this problem is at a higher level, e.g., in the parser.

However, you can do this using multiple input buffers.
\begin{verbatim}
%%
     macro/[a-z]+	{
     /* Saw the macro "macro" followed by extra stuff. */
     main_buffer = YY_CURRENT_BUFFER;
     expansion_buffer = yy_scan_string(expand(yytext));
     yy_switch_to_buffer(expansion_buffer);
     }
     
     <<EOF>>	{
     if ( expansion_buffer )
     {
     // We were doing an expansion, return to where
     // we were.
     yy_switch_to_buffer(main_buffer);
     yy_delete_buffer(expansion_buffer);
     expansion_buffer = 0;
     }
     else
     yyterminate();
     }
\end{verbatim}


You probably will want a stack of expansion buffers to allow nested macros. 
From the above though hopefully the idea is clear.
\section{How can I build a two-pass scanner?}


One way to do it is to filter the first pass to a temporary file,
then process the temporary file on the second pass. You will probably see a
performance hit, due to all the disk I/O.

When you need to look ahead far forward like this, it almost always means
that the right solution is to build a parse tree of the entire input, then
walk it after the parse in order to generate the output.  In a sense, this
is a two-pass approach, once through the text and once through the parse
tree, but the performance hit for the latter is usually an order of magnitude
smaller, since everything is already classified, in binary format, and
residing in memory.
\section{How do I match any string not matched in the preceding rules?}


One way to assign precedence, is to place the more specific rules first. If
two rules would match the same input (same sequence of characters) then the
first rule listed in the \verb`flex` input wins, e.g.,
\begin{verbatim}
%%
     foo[a-zA-Z_]+    return FOO_ID;
     bar[a-zA-Z_]+    return BAR_ID;
     [a-zA-Z_]+       return GENERIC_ID;
\end{verbatim}


Note that the rule \verb`[a-zA-Z_]+` must come *after* the others.  It will match the
same amount of text as the more specific rules, and in that case the \verb`flex` scanner will pick the first rule listed in your scanner as the
one to match.
\section{I am trying to port code from AT\&{}T lex that uses yysptr and yysbuf.}


Those are internal variables pointing into the AT\&{}T scanner's input buffer.  I
imagine they're being manipulated in user versions of the \verb`input()` and \verb`unput()` functions.  If so, what you need to do is analyze those functions to figure out
what they're doing, and then replace \verb`input()` with an appropriate definition of \verb`YY_INPUT` .  You shouldn't need to (and must not) replace \verb`flex` 's \verb`unput()` function.
\section{Is there a way to make flex treat NULL like a regular character?}


Yes, ‘\verb`\0`’ and ‘\verb`\x00`’ should both do the trick.  Perhaps you have an ancient
version of \verb`flex` .  The latest release is version 2.5.37.
\section{Whenever flex can not match the input it says "flex scanner jammed".}


You need to add a rule that matches the otherwise-unmatched text,
e.g.,
\begin{verbatim}
%option yylineno
     %%
     [[a bunch of rules here]]
     
     .	printf("bad input character '%s' at line %d\n", yytext, yylineno);
\end{verbatim}


See \verb`%option default` for more information.
\section{Why doesn't flex have non-greedy operators like perl does?}


A DFA can do a non-greedy match by stopping
the first time it enters an accepting state, instead of consuming input until
it determines that no further matching is possible (a “jam” state).  This
is actually easier to implement than longest leftmost match (which flex does).

But it's also much less useful than longest leftmost match.  In general,
when you find yourself wishing for non-greedy matching, that's usually a
sign that you're trying to make the scanner do some parsing.  That's
generally the wrong approach, since it lacks the power to do a decent job. 
Better is to either introduce a separate parser, or to split the scanner
into multiple scanners using (exclusive) start conditions.

You might have
a separate start state once you've seen the ‘\verb`BEGIN`’. In that state, you
might then have a regex that will match ‘\verb`END`’ (to kick you out of the
state), and perhaps ‘\verb`(.|\n)`’ to get a single character within the chunk ...

This approach also has much better error-reporting properties.
\section{Memory leak - 16386 bytes allocated by malloc.}


UPDATED 2002-07-10: As of \verb`flex` version 2.5.9, this leak means that you did not
call \verb`yylex_destroy()` . If you are using an earlier version of \verb`flex` , then read
on.

The leak is about 16426 bytes.  That is, (8192 * 2 + 2) for the read-buffer, and
about 40 for \verb`struct yy_buffer_state` (depending upon alignment). The leak is in
the non-reentrant C scanner only (NOT in the reentrant scanner, NOT in the C++
scanner). Since \verb`flex` doesn't know when you are done, the buffer is never freed.

However, the leak won't multiply since the buffer is reused no matter how many
times you call \verb`yylex()` .

If you want to reclaim the memory when you are completely done scanning, then
you might try this:
\begin{verbatim}
/* For non-reentrant C scanner only. */
     yy_delete_buffer(YY_CURRENT_BUFFER);
     yy_init = 1;
\end{verbatim}


Note: \verb`yy_init` is an "internal variable", and hasn't been tested in this
situation. It is possible that some other globals may need resetting as well.
\section{How do I track the byte offset for lseek()?}

\begin{verbatim}
>   We thought that it would be possible to have this number through the
     >   evaluation of the following expression:
     >
     >   seek_position = (no_buffers)*YY_READ_BUF_SIZE + yy_c_buf_p - YY_CURRENT_BUFFER->yy_ch_buf
\end{verbatim}


While this is the right idea, it has two problems.  The first is that
it's possible that \verb`flex` will request less than \verb`YY_READ_BUF_SIZE` during
an invocation of \verb`YY_INPUT` (or that your input source will return less
even though \verb`YY_READ_BUF_SIZE` bytes were requested).  The second problem
is that when refilling its internal buffer, \verb`flex` keeps some characters
from the previous buffer (because usually it's in the middle of a match,
and needs those characters to construct \verb`yytext` for the match once it's
done).  Because of this, \verb`yy_c_buf_p - YY_CURRENT_BUFFER->yy_ch_buf` won't
be exactly the number of characters already read from the current buffer.

An alternative solution is to count the number of characters you've matched
since starting to scan.  This can be done by using \verb`YY_USER_ACTION` .  For
example,
\begin{verbatim}
#define YY_USER_ACTION num_chars += yyleng;
\end{verbatim}


(You need to be careful to update your bookkeeping if you use \verb`yymore(` ), \verb`yyless()` , \verb`unput()` , or \verb`input()` .)
\section{How do I use my own I/O classes in a C++ scanner?}


When the flex C++ scanning class rewrite finally happens, then this sort of thing should become much easier.

You can do this by passing the various functions (such as \verb`LexerInput()` and \verb`LexerOutput()` ) NULL \verb`iostream*` 's, and then
dealing with your own I/O classes surreptitiously (i.e., stashing them in
special member variables).  This works because the only assumption about
the lexer regarding what's done with the iostream's is that they're
ultimately passed to \verb`LexerInput()` and \verb`LexerOutput` , which then do whatever
is necessary with them.
\section{How do I skip as many chars as possible?}


How do I skip as many chars as possible – without interfering with the other
patterns?

In the example below, we want to skip over characters until we see the phrase
"endskip". The following willwork correctly (do you see why not?)
\begin{verbatim}
/* INCORRECT SCANNER */
     %x SKIP
     %%
     <INITIAL>startskip   BEGIN(SKIP);
     ...
     <SKIP>"endskip"       BEGIN(INITIAL);
     <SKIP>.*             ;
\end{verbatim}


The problem is that the pattern .* will eat up the word "endskip." 
The simplest (but slow) fix is:
\begin{verbatim}
<SKIP>"endskip"      BEGIN(INITIAL);
     <SKIP>.              ;
\end{verbatim}


The fix involves making the second rule match more, without
making it match "endskip" plus something else.  So for example:
\begin{verbatim}
<SKIP>"endskip"     BEGIN(INITIAL);
     <SKIP>[^e]+         ;
     <SKIP>.		        ;/* so you eat up e's, too */
\end{verbatim}

\section{deleteme00}

\begin{verbatim}
QUESTION:
     When was flex born?
     
     Vern Paxson took over
     the Software Tools lex project from Jef Poskanzer in 1982.  At that point it
     was written in Ratfor.  Around 1987 or so, Paxson translated it into C, and
     a legend was born :-).
\end{verbatim}

\section{Are certain equivalent patterns faster than others?}

\begin{verbatim}
To: Adoram Rogel <adoram@orna.hybridge.com>
     Subject: Re: Flex 2.5.2 performance questions
     In-reply-to: Your message of Wed, 18 Sep 96 11:12:17 EDT.
     Date: Wed, 18 Sep 96 10:51:02 PDT
     From: Vern Paxson <vern>
     
     [Note, the most recent flex release is 2.5.4, which you can get from
     ftp.ee.lbl.gov.  It has bug fixes over 2.5.2 and 2.5.3.]
     
     > 1. Using the pattern
     >    ([Ff](oot)?)?[Nn](ote)?(\.)?
     >    instead of
     >    (((F|f)oot(N|n)ote)|((N|n)ote)|((N|n)\.)|((F|f)(N|n)(\.)))
     >    (in a very complicated flex program) caused the program to slow from
     >    300K+/min to 100K/min (no other changes were done).
     
     These two are not equivalent.  For example, the first can match "footnote."
     but the second can only match "footnote".  This is almost certainly the
     cause in the discrepancy - the slower scanner run is matching more tokens,
     and/or having to do more backing up.
     
     > 2. Which of these two are better: [Ff]oot or (F|f)oot ?
     
     From a performance point of view, they're equivalent (modulo presumably
     minor effects such as memory cache hit rates; and the presence of trailing
     context, see below).  From a space point of view, the first is slightly
     preferable.
     
     > 3. I have a pattern that look like this:
     >    pats {p1}|{p2}|{p3}|...|{p50}     (50 patterns ORd)
     >
     >    running yet another complicated program that includes the following rule:
     >    <snext>{and}/{no4}{bb}{pats}
     >
     >    gets me to "too complicated - over 32,000 states"...
     
     I can't tell from this example whether the trailing context is variable-length
     or fixed-length (it could be the latter if {and} is fixed-length).  If it's
     variable length, which flex -p will tell you, then this reflects a basic
     performance problem, and if you can eliminate it by restructuring your
     scanner, you will see significant improvement.
     
     >    so I divided {pats} to {pats1}, {pats2},..., {pats5} each consists of about
     >    10 patterns and changed the rule to be 5 rules.
     >    This did compile, but what is the rule of thumb here ?
     
     The rule is to avoid trailing context other than fixed-length, in which for
     a/b, either the 'a' pattern or the 'b' pattern have a fixed length.  Use
     of the '|' operator automatically makes the pattern variable length, so in
     this case '[Ff]oot' is preferred to '(F|f)oot'.
     
     > 4. I changed a rule that looked like this:
     >    <snext8>{and}{bb}/{ROMAN}[^A-Za-z] { BEGIN...
     >
     >    to the next 2 rules:
     >    <snext8>{and}{bb}/{ROMAN}[A-Za-z] { ECHO;}
     >    <snext8>{and}{bb}/{ROMAN}         { BEGIN...
     >
     >    Again, I understand the using [^...] will cause a great performance loss
     
     Actually, it doesn't cause any sort of performance loss.  It's a surprising
     fact about regular expressions that they always match in linear time
     regardless of how complex they are.
     
     >    but are there any specific rules about it ?
     
     See the "Performance Considerations" section of the man page, and also
     the example in MISC/fastwc/.
     
     		Vern
\end{verbatim}

\section{Is backing up a big deal?}

\begin{verbatim}
To: Adoram Rogel <adoram@hybridge.com>
     Subject: Re: Flex 2.5.2 performance questions
     In-reply-to: Your message of Thu, 19 Sep 96 10:16:04 EDT.
     Date: Thu, 19 Sep 96 09:58:00 PDT
     From: Vern Paxson <vern>
     
     > a lot about the backing up problem.
     > I believe that there lies my biggest problem, and I'll try to improve
     > it.
     
     Since you have variable trailing context, this is a bigger performance
     problem.  Fixing it is usually easier than fixing backing up, which in a
     complicated scanner (yours seems to fit the bill) can be extremely
     difficult to do correctly.
     
     You also don't mention what flags you are using for your scanner.
     -f makes a large speed difference, and -Cfe buys you nearly as much
     speed but the resulting scanner is considerably smaller.
     
     > I have an | operator in {and} and in {pats} so both of them are variable
     > length.
     
     -p should have reported this.
     
     > Is changing one of them to fixed-length is enough ?
     
     Yes.
     
     > Is it possible to change the 32,000 states limit ?
     
     Yes.  I've appended instructions on how.  Before you make this change,
     though, you should think about whether there are ways to fundamentally
     simplify your scanner - those are certainly preferable!
     
     		Vern
     
     To increase the 32K limit (on a machine with 32 bit integers), you increase
     the magnitude of the following in flexdef.h:
     
     #define JAMSTATE -32766 /* marks a reference to the state that always jams */
     #define MAXIMUM_MNS 31999
     #define BAD_SUBSCRIPT -32767
     #define MAX_SHORT 32700
     
     Adding a 0 or two after each should do the trick.
\end{verbatim}

\section{Can I fake multi-byte character support?}

\begin{verbatim}
To: Heeman_Lee@hp.com
     Subject: Re: flex - multi-byte support?
     In-reply-to: Your message of Thu, 03 Oct 1996 17:24:04 PDT.
     Date: Fri, 04 Oct 1996 11:42:18 PDT
     From: Vern Paxson <vern>
     
     >      I assume as long as my *.l file defines the
     >      range of expected character code values (in octal format), flex will
     >      scan the file and read multi-byte characters correctly. But I have no
     >      confidence in this assumption.
     
     Your lack of confidence is justified - this won't work.
     
     Flex has in it a widespread assumption that the input is processed
     one byte at a time.  Fixing this is on the to-do list, but is involved,
     so it won't happen any time soon.  In the interim, the best I can suggest
     (unless you want to try fixing it yourself) is to write your rules in
     terms of pairs of bytes, using definitions in the first section:
     
     	X	\xfe\xc2
     	...
     	%%
     	foo{X}bar	found_foo_fe_c2_bar();
     
     etc.  Definitely a pain - sorry about that.
     
     By the way, the email address you used for me is ancient, indicating you
     have a very old version of flex.  You can get the most recent, 2.5.4, from
     ftp.ee.lbl.gov.
     
     		Vern
\end{verbatim}

\section{deleteme01}

\begin{verbatim}
To: moleary@primus.com
     Subject: Re: Flex / Unicode compatibility question
     In-reply-to: Your message of Tue, 22 Oct 1996 10:15:42 PDT.
     Date: Tue, 22 Oct 1996 11:06:13 PDT
     From: Vern Paxson <vern>
     
     Unfortunately flex at the moment has a widespread assumption within it
     that characters are processed 8 bits at a time.  I don't see any easy
     fix for this (other than writing your rules in terms of double characters -
     a pain).  I also don't know of a wider lex, though you might try surfing
     the Plan 9 stuff because I know it's a Unicode system, and also the PCCT
     toolkit (try searching say Alta Vista for "Purdue Compiler Construction
     Toolkit").
     
     Fixing flex to handle wider characters is on the long-term to-do list.
     But since flex is a strictly spare-time project these days, this probably
     won't happen for quite a while, unless someone else does it first.
     
     		Vern
\end{verbatim}

\section{Can you discuss some flex internals?}

\begin{verbatim}
To: Johan Linde <jl@theophys.kth.se>
     Subject: Re: translation of flex
     In-reply-to: Your message of Sun, 10 Nov 1996 09:16:36 PST.
     Date: Mon, 11 Nov 1996 10:33:50 PST
     From: Vern Paxson <vern>
     
     > I'm working for the Swedish team translating GNU program, and I'm currently
     > working with flex. I have a few questions about some of the messages which
     > I hope you can answer.
     
     All of the things you're wondering about, by the way, concerning flex
     internals - probably the only person who understands what they mean in
     English is me!  So I wouldn't worry too much about getting them right.
     That said ...
     
     > #: main.c:545
     > msgid "  %d protos created\n"
     >
     > Does proto mean prototype?
     
     Yes - prototypes of state compression tables.
     
     > #: main.c:539
     > msgid "  %d/%d (peak %d) template nxt-chk entries created\n"
     >
     > Here I'm mainly puzzled by 'nxt-chk'. I guess it means 'next-check'. (?)
     > However, 'template next-check entries' doesn't make much sense to me. To be
     > able to find a good translation I need to know a little bit more about it.
     
     There is a scheme in the Aho/Sethi/Ullman compiler book for compressing
     scanner tables.  It involves creating two pairs of tables.  The first has
     "base" and "default" entries, the second has "next" and "check" entries.
     The "base" entry is indexed by the current state and yields an index into
     the next/check table.  The "default" entry gives what to do if the state
     transition isn't found in next/check.  The "next" entry gives the next
     state to enter, but only if the "check" entry verifies that this entry is
     correct for the current state.  Flex creates templates of series of
     next/check entries and then encodes differences from these templates as a
     way to compress the tables.
     
     > #: main.c:533
     > msgid "  %d/%d base-def entries created\n"
     >
     > The same problem here for 'base-def'.
     
     See above.
     
     		Vern
\end{verbatim}

\section{unput() messes up yy\_{}at\_{}bol}

\begin{verbatim}
To: Xinying Li <xli@npac.syr.edu>
     Subject: Re: FLEX ?
     In-reply-to: Your message of Wed, 13 Nov 1996 17:28:38 PST.
     Date: Wed, 13 Nov 1996 19:51:54 PST
     From: Vern Paxson <vern>
     
     > "unput()" them to input flow, question occurs. If I do this after I scan
     > a carriage, the variable "YY_CURRENT_BUFFER->yy_at_bol" is changed. That
     > means the carriage flag has gone.
     
     You can control this by calling yy_set_bol().  It's described in the manual.
     
     >      And if in pre-reading it goes to the end of file, is anything done
     > to control the end of curren buffer and end of file?
     
     No, there's no way to put back an end-of-file.
     
     >      By the way I am using flex 2.5.2 and using the "-l".
     
     The latest release is 2.5.4, by the way.  It fixes some bugs in 2.5.2 and
     2.5.3.  You can get it from ftp.ee.lbl.gov.
     
     		Vern
\end{verbatim}

\section{The | operator is not doing what I want}

\begin{verbatim}
To: Alain.ISSARD@st.com
     Subject: Re: Start condition with FLEX
     In-reply-to: Your message of Mon, 18 Nov 1996 09:45:02 PST.
     Date: Mon, 18 Nov 1996 10:41:34 PST
     From: Vern Paxson <vern>
     
     > I am not able to use the start condition scope and to use the | (OR) with
     > rules having start conditions.
     
     The problem is that if you use '|' as a regular expression operator, for
     example "a|b" meaning "match either 'a' or 'b'", then it must *not* have
     any blanks around it.  If you instead want the special '|' *action* (which
     from your scanner appears to be the case), which is a way of giving two
     different rules the same action:
     
     	foo	|
     	bar	matched_foo_or_bar();
     
     then '|' *must* be separated from the first rule by whitespace and *must*
     be followed by a new line.  You *cannot* write it as:
     
     	foo | bar	matched_foo_or_bar();
     
     even though you might think you could because yacc supports this syntax.
     The reason for this unfortunately incompatibility is historical, but it's
     unlikely to be changed.
     
     Your problems with start condition scope are simply due to syntax errors
     from your use of '|' later confusing flex.
     
     Let me know if you still have problems.
     
     		Vern
\end{verbatim}

\section{Why can't flex understand this variable trailing context pattern?}

\begin{verbatim}
To: Gregory Margo <gmargo@newton.vip.best.com>
     Subject: Re: flex-2.5.3 bug report
     In-reply-to: Your message of Sat, 23 Nov 1996 16:50:09 PST.
     Date: Sat, 23 Nov 1996 17:07:32 PST
     From: Vern Paxson <vern>
     
     > Enclosed is a lex file that "real" lex will process, but I cannot get
     > flex to process it.  Could you try it and maybe point me in the right direction?
     
     Your problem is that some of the definitions in the scanner use the '/'
     trailing context operator, and have it enclosed in ()'s.  Flex does not
     allow this operator to be enclosed in ()'s because doing so allows undefined
     regular expressions such as "(a/b)+".  So the solution is to remove the
     parentheses.  Note that you must also be building the scanner with the -l
     option for AT&T lex compatibility.  Without this option, flex automatically
     encloses the definitions in parentheses.
     
     		Vern
\end{verbatim}

\section{The \^ operator isn't working}

\begin{verbatim}
To: Thomas Hadig <hadig@toots.physik.rwth-aachen.de>
     Subject: Re: Flex Bug ?
     In-reply-to: Your message of Tue, 26 Nov 1996 14:35:01 PST.
     Date: Tue, 26 Nov 1996 11:15:05 PST
     From: Vern Paxson <vern>
     
     > In my lexer code, i have the line :
     > ^\*.*          { }
     >
     > Thus all lines starting with an astrix (*) are comment lines.
     > This does not work !
     
     I can't get this problem to reproduce - it works fine for me.  Note
     though that if what you have is slightly different:
     
     	COMMENT	^\*.*
     	%%
     	{COMMENT}	{ }
     
     then it won't work, because flex pushes back macro definitions enclosed
     in ()'s, so the rule becomes
     
     	(^\*.*)		{ }
     
     and now that the '^' operator is not at the immediate beginning of the
     line, it's interpreted as just a regular character.  You can avoid this
     behavior by using the "-l" lex-compatibility flag, or "%option lex-compat".
     
     		Vern
\end{verbatim}

\section{Trailing context is getting confused with trailing optional patterns}

\begin{verbatim}
To: Adoram Rogel <adoram@hybridge.com>
     Subject: Re: Flex 2.5.4 BOF ???
     In-reply-to: Your message of Tue, 26 Nov 1996 16:10:41 PST.
     Date: Wed, 27 Nov 1996 10:56:25 PST
     From: Vern Paxson <vern>
     
     >     Organization(s)?/[a-z]
     >
     > This matched "Organizations" (looking in debug mode, the trailing s
     > was matched with trailing context instead of the optional (s) in the
     > end of the word.
     
     That should only happen with lex.  Flex can properly match this pattern.
     (That might be what you're saying, I'm just not sure.)
     
     > Is there a way to avoid this dangerous trailing context problem ?
     
     Unfortunately, there's no easy way.  On the other hand, I don't see why
     it should be a problem.  Lex's matching is clearly wrong, and I'd hope
     that usually the intent remains the same as expressed with the pattern,
     so flex's matching will be correct.
     
     		Vern
\end{verbatim}

\section{Is flex GNU or not?}

\begin{verbatim}
To: Cameron MacKinnon <mackin@interlog.com>
     Subject: Re: Flex documentation bug
     In-reply-to: Your message of Mon, 02 Dec 1996 00:07:08 PST.
     Date: Sun, 01 Dec 1996 22:29:39 PST
     From: Vern Paxson <vern>
     
     > I'm not sure how or where to submit bug reports (documentation or
     > otherwise) for the GNU project stuff ...
     
     Well, strictly speaking flex isn't part of the GNU project.  They just
     distribute it because no one's written a decent GPL'd lex replacement.
     So you should send bugs directly to me.  Those sent to the GNU folks
     sometimes find there way to me, but some may drop between the cracks.
     
     > In GNU Info, under the section 'Start Conditions', and also in the man
     > page (mine's dated April '95) is a nice little snippet showing how to
     > parse C quoted strings into a buffer, defined to be MAX_STR_CONST in
     > size. Unfortunately, no overflow checking is ever done ...
     
     This is already mentioned in the manual:
     
     Finally, here's an example of how to  match  C-style  quoted
     strings using exclusive start conditions, including expanded
     escape sequences (but not including checking  for  a  string
     that's too long):
     
     The reason for not doing the overflow checking is that it will needlessly
     clutter up an example whose main purpose is just to demonstrate how to
     use flex.
     
     The latest release is 2.5.4, by the way, available from ftp.ee.lbl.gov.
     
     		Vern
\end{verbatim}

\section{ERASEME53}

\begin{verbatim}
To: tsv@cs.UManitoba.CA
     Subject: Re: Flex (reg)..
     In-reply-to: Your message of Thu, 06 Mar 1997 23:50:16 PST.
     Date: Thu, 06 Mar 1997 15:54:19 PST
     From: Vern Paxson <vern>
     
     > [:alpha:] ([:alnum:] | \\_)*
     
     If your rule really has embedded blanks as shown above, then it won't
     work, as the first blank delimits the rule from the action.  (It wouldn't
     even compile ...)  You need instead:
     
     [:alpha:]([:alnum:]|\\_)*
     
     and that should work fine - there's no restriction on what can go inside
     of ()'s except for the trailing context operator, '/'.
     
     		Vern
\end{verbatim}

\section{I need to scan if-then-else blocks and while loops}

\begin{verbatim}
To: "Mike Stolnicki" <mstolnic@ford.com>
     Subject: Re: FLEX help
     In-reply-to: Your message of Fri, 30 May 1997 13:33:27 PDT.
     Date: Fri, 30 May 1997 10:46:35 PDT
     From: Vern Paxson <vern>
     
     > We'd like to add "if-then-else", "while", and "for" statements to our
     > language ...
     > We've investigated many possible solutions.  The one solution that seems
     > the most reasonable involves knowing the position of a TOKEN in yyin.
     
     I strongly advise you to instead build a parse tree (abstract syntax tree)
     and loop over that instead.  You'll find this has major benefits in keeping
     your interpreter simple and extensible.
     
     That said, the functionality you mention for get_position and set_position
     have been on the to-do list for a while.  As flex is a purely spare-time
     project for me, no guarantees when this will be added (in particular, it
     for sure won't be for many months to come).
     
     		Vern
\end{verbatim}

\section{ERASEME55}

\begin{verbatim}
To: Colin Paul Adams <colin@colina.demon.co.uk>
     Subject: Re: Flex C++ classes and Bison
     In-reply-to: Your message of 09 Aug 1997 17:11:41 PDT.
     Date: Fri, 15 Aug 1997 10:48:19 PDT
     From: Vern Paxson <vern>
     
     > #define YY_DECL   int yylex (YYSTYPE *lvalp, struct parser_control
     > *parm)
     >
     > I have been trying  to get this to work as a C++ scanner, but it does
     > not appear to be possible (warning that it matches no declarations in
     > yyFlexLexer, or something like that).
     >
     > Is this supposed to be possible, or is it being worked on (I DID
     > notice the comment that scanner classes are still experimental, so I'm
     > not too hopeful)?
     
     What you need to do is derive a subclass from yyFlexLexer that provides
     the above yylex() method, squirrels away lvalp and parm into member
     variables, and then invokes yyFlexLexer::yylex() to do the regular scanning.
     
     		Vern
\end{verbatim}

\section{ERASEME56}

\begin{verbatim}
To: Mikael.Latvala@lmf.ericsson.se
     Subject: Re: Possible mistake in Flex v2.5 document
     In-reply-to: Your message of Fri, 05 Sep 1997 16:07:24 PDT.
     Date: Fri, 05 Sep 1997 10:01:54 PDT
     From: Vern Paxson <vern>
     
     > In that example you show how to count comment lines when using
     > C style /* ... */ comments. My question is, shouldn't you take into
     > account a scenario where end of a comment marker occurs inside
     > character or string literals?
     
     The scanner certainly needs to also scan character and string literals.
     However it does that (there's an example in the man page for strings), the
     lexer will recognize the beginning of the literal before it runs across the
     embedded "/*".  Consequently, it will finish scanning the literal before it
     even considers the possibility of matching "/*".
     
     Example:
     
     	'([^']*|{ESCAPE_SEQUENCE})'
     
     will match all the text between the ''s (inclusive).  So the lexer
     considers this as a token beginning at the first ', and doesn't even
     attempt to match other tokens inside it.
     
     I thinnk this subtlety is not worth putting in the manual, as I suspect
     it would confuse more people than it would enlighten.
     
     		Vern
\end{verbatim}

\section{ERASEME57}

\begin{verbatim}
To: "Marty Leisner" <leisner@sdsp.mc.xerox.com>
     Subject: Re: flex limitations
     In-reply-to: Your message of Sat, 06 Sep 1997 11:27:21 PDT.
     Date: Mon, 08 Sep 1997 11:38:08 PDT
     From: Vern Paxson <vern>
     
     > %%
     > [a-zA-Z]+       /* skip a line */
     >                 {  printf("got %s\n", yytext); }
     > %%
     
     What version of flex are you using?  If I feed this to 2.5.4, it complains:
     
     	"bug.l", line 5: EOF encountered inside an action
     	"bug.l", line 5: unrecognized rule
     	"bug.l", line 5: fatal parse error
     
     Not the world's greatest error message, but it manages to flag the problem.
     
     (With the introduction of start condition scopes, flex can't accommodate
     an action on a separate line, since it's ambiguous with an indented rule.)
     
     You can get 2.5.4 from ftp.ee.lbl.gov.
     
     		Vern
\end{verbatim}

\section{Is there a repository for flex scanners?}


Not that we know of. You might try asking on comp.compilers.
\section{How can I conditionally compile or preprocess my flex input file?}


Flex doesn't have a preprocessor like C does.  You might try using m4, or the C
preprocessor plus a sed script to clean up the result.
\section{Where can I find grammars for lex and yacc?}


In the sources for flex and bison.
\section{I get an end-of-buffer message for each character scanned.}


This will happen if your LexerInput() function returns only one character
at a time, which can happen either if you're scanner is "interactive", or
if the streams library on your platform always returns 1 for yyin->gcount().

Solution: override LexerInput() with a version that returns whole buffers.
\section{unnamed-faq-62}

\begin{verbatim}
To: Georg.Rehm@CL-KI.Uni-Osnabrueck.DE
     Subject: Re: Flex maximums
     In-reply-to: Your message of Mon, 17 Nov 1997 17:16:06 PST.
     Date: Mon, 17 Nov 1997 17:16:15 PST
     From: Vern Paxson <vern>
     
     > I took a quick look into the flex-sources and altered some #defines in
     > flexdefs.h:
     >
     > 	#define INITIAL_MNS 64000
     > 	#define MNS_INCREMENT 1024000
     > 	#define MAXIMUM_MNS 64000
     
     The things to fix are to add a couple of zeroes to:
     
     #define JAMSTATE -32766 /* marks a reference to the state that always jams */
     #define MAXIMUM_MNS 31999
     #define BAD_SUBSCRIPT -32767
     #define MAX_SHORT 32700
     
     and, if you get complaints about too many rules, make the following change too:
     
     	#define YY_TRAILING_MASK 0x200000
     	#define YY_TRAILING_HEAD_MASK 0x400000
     
     - Vern
\end{verbatim}

\section{unnamed-faq-63}

\begin{verbatim}
To: jimmey@lexis-nexis.com (Jimmey Todd)
     Subject: Re: FLEX question regarding istream vs ifstream
     In-reply-to: Your message of Mon, 08 Dec 1997 15:54:15 PST.
     Date: Mon, 15 Dec 1997 13:21:35 PST
     From: Vern Paxson <vern>
     
     >         stdin_handle = YY_CURRENT_BUFFER;
     >         ifstream fin( "aFile" );
     >         yy_switch_to_buffer( yy_create_buffer( fin, YY_BUF_SIZE ) );
     >
     > What I'm wanting to do, is pass the contents of a file thru one set
     > of rules and then pass stdin thru another set... It works great if, I
     > don't use the C++ classes. But since everything else that I'm doing is
     > in C++, I thought I'd be consistent.
     >
     > The problem is that 'yy_create_buffer' is expecting an istream* as it's
     > first argument (as stated in the man page). However, fin is a ifstream
     > object. Any ideas on what I might be doing wrong? Any help would be
     > appreciated. Thanks!!
     
     You need to pass &fin, to turn it into an ifstream* instead of an ifstream.
     Then its type will be compatible with the expected istream*, because ifstream
     is derived from istream.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-64}

\begin{verbatim}
To: Enda Fadian <fadiane@piercom.ie>
     Subject: Re: Question related to Flex man page?
     In-reply-to: Your message of Tue, 16 Dec 1997 15:17:34 PST.
     Date: Tue, 16 Dec 1997 14:17:09 PST
     From: Vern Paxson <vern>
     
     > Can you explain to me what is ment by a long-jump in relation to flex?
     
     Using the longjmp() function while inside yylex() or a routine called by it.
     
     > what is the flex activation frame.
     
     Just yylex()'s stack frame.
     
     > As far as I can see yyrestart will bring me back to the sart of the input
     > file and using flex++ isnot really an option!
     
     No, yyrestart() doesn't imply a rewind, even though its name might sound
     like it does.  It tells the scanner to flush its internal buffers and
     start reading from the given file at its present location.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-65}

\begin{verbatim}
To: hassan@larc.info.uqam.ca (Hassan Alaoui)
     Subject: Re: Need urgent Help
     In-reply-to: Your message of Sat, 20 Dec 1997 19:38:19 PST.
     Date: Sun, 21 Dec 1997 21:30:46 PST
     From: Vern Paxson <vern>
     
     > /usr/lib/yaccpar: In function `int yyparse()':
     > /usr/lib/yaccpar:184: warning: implicit declaration of function `int yylex(...)'
     >
     > ld: Undefined symbol
     >    _yylex
     >    _yyparse
     >    _yyin
     
     This is a known problem with Solaris C++ (and/or Solaris yacc).  I believe
     the fix is to explicitly insert some 'extern "C"' statements for the
     corresponding routines/symbols.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-66}

\begin{verbatim}
To: mc0307@mclink.it
     Cc: gnu@prep.ai.mit.edu
     Subject: Re: [mc0307@mclink.it: Help request]
     In-reply-to: Your message of Fri, 12 Dec 1997 17:57:29 PST.
     Date: Sun, 21 Dec 1997 22:33:37 PST
     From: Vern Paxson <vern>
     
     > This is my definition for float and integer types:
     > . . .
     > NZD          [1-9]
     > ...
     > I've tested my program on other lex version (on UNIX Sun Solaris an HP
     > UNIX) and it work well, so I think that my definitions are correct.
     > There are any differences between Lex and Flex?
     
     There are indeed differences, as discussed in the man page.  The one
     you are probably running into is that when flex expands a name definition,
     it puts parentheses around the expansion, while lex does not.  There's
     an example in the man page of how this can lead to different matching.
     Flex's behavior complies with the POSIX standard (or at least with the
     last POSIX draft I saw).
     
     		Vern
\end{verbatim}

\section{unnamed-faq-67}

\begin{verbatim}
To: hassan@larc.info.uqam.ca (Hassan Alaoui)
     Subject: Re: Thanks
     In-reply-to: Your message of Mon, 22 Dec 1997 16:06:35 PST.
     Date: Mon, 22 Dec 1997 14:35:05 PST
     From: Vern Paxson <vern>
     
     > Thank you very much for your help. I compile and link well with C++ while
     > declaring 'yylex ...' extern, But a little problem remains. I get a
     > segmentation default when executing ( I linked with lfl library) while it
     > works well when using LEX instead of flex. Do you have some ideas about the
     > reason for this ?
     
     The one possible reason for this that comes to mind is if you've defined
     yytext as "extern char yytext[]" (which is what lex uses) instead of
     "extern char *yytext" (which is what flex uses).  If it's not that, then
     I'm afraid I don't know what the problem might be.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-68}

\begin{verbatim}
To: "Bart Niswonger" <NISWONGR@almaden.ibm.com>
     Subject: Re: flex 2.5: c++ scanners & start conditions
     In-reply-to: Your message of Tue, 06 Jan 1998 10:34:21 PST.
     Date: Tue, 06 Jan 1998 19:19:30 PST
     From: Vern Paxson <vern>
     
     > The problem is that when I do this (using %option c++) start
     > conditions seem to not apply.
     
     The BEGIN macro modifies the yy_start variable.  For C scanners, this
     is a static with scope visible through the whole file.  For C++ scanners,
     it's a member variable, so it only has visible scope within a member
     function.  Your lexbegin() routine is not a member function when you
     build a C++ scanner, so it's not modifying the correct yy_start.  The
     diagnostic that indicates this is that you found you needed to add
     a declaration of yy_start in order to get your scanner to compile when
     using C++; instead, the correct fix is to make lexbegin() a member
     function (by deriving from yyFlexLexer).
     
     		Vern
\end{verbatim}

\section{unnamed-faq-69}

\begin{verbatim}
To: "Boris Zinin" <boris@ippe.rssi.ru>
     Subject: Re: current position in flex buffer
     In-reply-to: Your message of Mon, 12 Jan 1998 18:58:23 PST.
     Date: Mon, 12 Jan 1998 12:03:15 PST
     From: Vern Paxson <vern>
     
     > The problem is how to determine the current position in flex active
     > buffer when a rule is matched....
     
     You will need to keep track of this explicitly, such as by redefining
     YY_USER_ACTION to count the number of characters matched.
     
     The latest flex release, by the way, is 2.5.4, available from ftp.ee.lbl.gov.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-70}

\begin{verbatim}
To: Bik.Dhaliwal@bis.org
     Subject: Re: Flex question
     In-reply-to: Your message of Mon, 26 Jan 1998 13:05:35 PST.
     Date: Tue, 27 Jan 1998 22:41:52 PST
     From: Vern Paxson <vern>
     
     > That requirement involves knowing
     > the character position at which a particular token was matched
     > in the lexer.
     
     The way you have to do this is by explicitly keeping track of where
     you are in the file, by counting the number of characters scanned
     for each token (available in yyleng).  It may prove convenient to
     do this by redefining YY_USER_ACTION, as described in the manual.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-71}

\begin{verbatim}
To: Vladimir Alexiev <vladimir@cs.ualberta.ca>
     Subject: Re: flex: how to control start condition from parser?
     In-reply-to: Your message of Mon, 26 Jan 1998 05:50:16 PST.
     Date: Tue, 27 Jan 1998 22:45:37 PST
     From: Vern Paxson <vern>
     
     > It seems useful for the parser to be able to tell the lexer about such
     > context dependencies, because then they don't have to be limited to
     > local or sequential context.
     
     One way to do this is to have the parser call a stub routine that's
     included in the scanner's .l file, and consequently that has access ot
     BEGIN.  The only ugliness is that the parser can't pass in the state
     it wants, because those aren't visible - but if you don't have many
     such states, then using a different set of names doesn't seem like
     to much of a burden.
     
     While generating a .h file like you suggests is certainly cleaner,
     flex development has come to a virtual stand-still :-(, so a workaround
     like the above is much more pragmatic than waiting for a new feature.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-72}

\begin{verbatim}
To: Barbara Denny <denny@3com.com>
     Subject: Re: freebsd flex bug?
     In-reply-to: Your message of Fri, 30 Jan 1998 12:00:43 PST.
     Date: Fri, 30 Jan 1998 12:42:32 PST
     From: Vern Paxson <vern>
     
     > lex.yy.c:1996: parse error before `='
     
     This is the key, identifying this error.  (It may help to pinpoint
     it by using flex -L, so it doesn't generate #line directives in its
     output.)  I will bet you heavy money that you have a start condition
     name that is also a variable name, or something like that; flex spits
     out #define's for each start condition name, mapping them to a number,
     so you can wind up with:
     
     	%x foo
     	%%
     		...
     	%%
     	void bar()
     		{
     		int foo = 3;
     		}
     
     and the penultimate will turn into "int 1 = 3" after C preprocessing,
     since flex will put "#define foo 1" in the generated scanner.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-73}

\begin{verbatim}
To: Maurice Petrie <mpetrie@infoscigroup.com>
     Subject: Re: Lost flex .l file
     In-reply-to: Your message of Mon, 02 Feb 1998 14:10:01 PST.
     Date: Mon, 02 Feb 1998 11:15:12 PST
     From: Vern Paxson <vern>
     
     > I am curious as to
     > whether there is a simple way to backtrack from the generated source to
     > reproduce the lost list of tokens we are searching on.
     
     In theory, it's straight-forward to go from the DFA representation
     back to a regular-expression representation - the two are isomorphic.
     In practice, a huge headache, because you have to unpack all the tables
     back into a single DFA representation, and then write a program to munch
     on that and translate it into an RE.
     
     Sorry for the less-than-happy news ...
     
     		Vern
\end{verbatim}

\section{unnamed-faq-74}

\begin{verbatim}
To: jimmey@lexis-nexis.com (Jimmey Todd)
     Subject: Re: Flex performance question
     In-reply-to: Your message of Thu, 19 Feb 1998 11:01:17 PST.
     Date: Thu, 19 Feb 1998 08:48:51 PST
     From: Vern Paxson <vern>
     
     > What I have found, is that the smaller the data chunk, the faster the
     > program executes. This is the opposite of what I expected. Should this be
     > happening this way?
     
     This is exactly what will happen if your input file has embedded NULs.
     From the man page:
     
     A final note: flex is slow when matching NUL's, particularly
     when  a  token  contains multiple NUL's.  It's best to write
     rules which match short amounts of text if it's  anticipated
     that the text will often include NUL's.
     
     So that's the first thing to look for.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-75}

\begin{verbatim}
To: jimmey@lexis-nexis.com (Jimmey Todd)
     Subject: Re: Flex performance question
     In-reply-to: Your message of Thu, 19 Feb 1998 11:01:17 PST.
     Date: Thu, 19 Feb 1998 15:42:25 PST
     From: Vern Paxson <vern>
     
     So there are several problems.
     
     First, to go fast, you want to match as much text as possible, which
     your scanners don't in the case that what they're scanning is *not*
     a <RN> tag.  So you want a rule like:
     
     	[^<]+
     
     Second, C++ scanners are particularly slow if they're interactive,
     which they are by default.  Using -B speeds it up by a factor of 3-4
     on my workstation.
     
     Third, C++ scanners that use the istream interface are slow, because
     of how poorly implemented istream's are.  I built two versions of
     the following scanner:
     
     	%%
     	.*\n
     	.*
     	%%
     
     and the C version inhales a 2.5MB file on my workstation in 0.8 seconds.
     The C++ istream version, using -B, takes 3.8 seconds.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-76}

\begin{verbatim}
To: "Frescatore, David (CRD, TAD)" <frescatore@exc01crdge.crd.ge.com>
     Subject: Re: FLEX 2.5 & THE YEAR 2000
     In-reply-to: Your message of Wed, 03 Jun 1998 11:26:22 PDT.
     Date: Wed, 03 Jun 1998 10:22:26 PDT
     From: Vern Paxson <vern>
     
     > I am researching the Y2K problem with General Electric R&D
     > and need to know if there are any known issues concerning
     > the above mentioned software and Y2K regardless of version.
     
     There shouldn't be, all it ever does with the date is ask the system
     for it and then print it out.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-77}

\begin{verbatim}
To: "Hans Dermot Doran" <htd@ibhdoran.com>
     Subject: Re: flex problem
     In-reply-to: Your message of Wed, 15 Jul 1998 21:30:13 PDT.
     Date: Tue, 21 Jul 1998 14:23:34 PDT
     From: Vern Paxson <vern>
     
     > To overcome this, I gets() the stdin into a string and lex the string. The
     > string is lexed OK except that the end of string isn't lexed properly
     > (yy_scan_string()), that is the lexer dosn't recognise the end of string.
     
     Flex doesn't contain mechanisms for recognizing buffer endpoints.  But if
     you use fgets instead (which you should anyway, to protect against buffer
     overflows), then the final \n will be preserved in the string, and you can
     scan that in order to find the end of the string.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-78}

\begin{verbatim}
To: soumen@almaden.ibm.com
     Subject: Re: Flex++ 2.5.3 instance member vs. static member
     In-reply-to: Your message of Mon, 27 Jul 1998 02:10:04 PDT.
     Date: Tue, 28 Jul 1998 01:10:34 PDT
     From: Vern Paxson <vern>
     
     > %{
     > int mylineno = 0;
     > %}
     > ws      [ \t]+
     > alpha   [A-Za-z]
     > dig     [0-9]
     > %%
     >
     > Now you'd expect mylineno to be a member of each instance of class
     > yyFlexLexer, but is this the case?  A look at the lex.yy.cc file seems to
     > indicate otherwise; unless I am missing something the declaration of
     > mylineno seems to be outside any class scope.
     >
     > How will this work if I want to run a multi-threaded application with each
     > thread creating a FlexLexer instance?
     
     Derive your own subclass and make mylineno a member variable of it.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-79}

\begin{verbatim}
To: Adoram Rogel <adoram@hybridge.com>
     Subject: Re: More than 32K states change hangs
     In-reply-to: Your message of Tue, 04 Aug 1998 16:55:39 PDT.
     Date: Tue, 04 Aug 1998 22:28:45 PDT
     From: Vern Paxson <vern>
     
     > Vern Paxson,
     >
     > I followed your advice, posted on Usenet bu you, and emailed to me
     > personally by you, on how to overcome the 32K states limit. I'm running
     > on Linux machines.
     > I took the full source of version 2.5.4 and did the following changes in
     > flexdef.h:
     > #define JAMSTATE -327660
     > #define MAXIMUM_MNS 319990
     > #define BAD_SUBSCRIPT -327670
     > #define MAX_SHORT 327000
     >
     > and compiled.
     > All looked fine, including check and bigcheck, so I installed.
     
     Hmmm, you shouldn't increase MAX_SHORT, though looking through my email
     archives I see that I did indeed recommend doing so.  Try setting it back
     to 32700; that should suffice that you no longer need -Ca.  If it still
     hangs, then the interesting question is - where?
     
     > Compiling the same hanged program with a out-of-the-box (RedHat 4.2
     > distribution of Linux)
     > flex 2.5.4 binary works.
     
     Since Linux comes with source code, you should diff it against what
     you have to see what problems they missed.
     
     > Should I always compile with the -Ca option now ? even short and simple
     > filters ?
     
     No, definitely not.  It's meant to be for those situations where you
     absolutely must squeeze every last cycle out of your scanner.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-80}

\begin{verbatim}
To: "Schmackpfeffer, Craig" <Craig.Schmackpfeffer@usa.xerox.com>
     Subject: Re: flex output for static code portion
     In-reply-to: Your message of Tue, 11 Aug 1998 11:55:30 PDT.
     Date: Mon, 17 Aug 1998 23:57:42 PDT
     From: Vern Paxson <vern>
     
     > I would like to use flex under the hood to generate a binary file
     > containing the data structures that control the parse.
     
     This has been on the wish-list for a long time.  In principle it's
     straight-forward - you redirect mkdata() et al's I/O to another file,
     and modify the skeleton to have a start-up function that slurps these
     into dynamic arrays.  The concerns are (1) the scanner generation code
     is hairy and full of corner cases, so it's easy to get surprised when
     going down this path :-( ; and (2) being careful about buffering so
     that when the tables change you make sure the scanner starts in the
     correct state and reading at the right point in the input file.
     
     > I was wondering if you know of anyone who has used flex in this way.
     
     I don't - but it seems like a reasonable project to undertake (unlike
     numerous other flex tweaks :-).
     
     		Vern
\end{verbatim}

\section{unnamed-faq-81}

\begin{verbatim}
Received: from 131.173.17.11 (131.173.17.11 [131.173.17.11])
     	by ee.lbl.gov (8.9.1/8.9.1) with ESMTP id AAA03838
     	for <vern@ee.lbl.gov>; Thu, 20 Aug 1998 00:47:57 -0700 (PDT)
     Received: from hal.cl-ki.uni-osnabrueck.de (hal.cl-ki.Uni-Osnabrueck.DE [131.173.141.2])
     	by deimos.rz.uni-osnabrueck.de (8.8.7/8.8.8) with ESMTP id JAA34694
     	for <vern@ee.lbl.gov>; Thu, 20 Aug 1998 09:47:55 +0200
     Received: (from georg@localhost) by hal.cl-ki.uni-osnabrueck.de (8.6.12/8.6.12) id JAA34834 for vern@ee.lbl.gov; Thu, 20 Aug 1998 09:47:54 +0200
     From: Georg Rehm <georg@hal.cl-ki.uni-osnabrueck.de>
     Message-Id: <199808200747.JAA34834@hal.cl-ki.uni-osnabrueck.de>
     Subject: "flex scanner push-back overflow"
     To: vern@ee.lbl.gov
     Date: Thu, 20 Aug 1998 09:47:54 +0200 (MEST)
     Reply-To: Georg.Rehm@CL-KI.Uni-Osnabrueck.DE
     X-NoJunk: Do NOT send commercial mail, spam or ads to this address!
     X-URL: http://www.cl-ki.uni-osnabrueck.de/~georg/
     X-Mailer: ELM [version 2.4ME+ PL28 (25)]
     MIME-Version: 1.0
     Content-Type: text/plain; charset=US-ASCII
     Content-Transfer-Encoding: 7bit
     
     Hi Vern,
     
     Yesterday, I encountered a strange problem: I use the macro processor m4
     to include some lengthy lists into a .l file. Following is a flex macro
     definition that causes some serious pain in my neck:
     
     AUTHOR           ("A. Boucard / L. Boucard"|"A. Dastarac / M. Levent"|"A.Boucaud / L.Boucaud"|"Abderrahim Lamchichi"|"Achmat Dangor"|"Adeline Toullier"|"Adewale Maja-Pearce"|"Ahmed Ziri"|"Akram Ellyas"|"Alain Bihr"|"Alain Gresh"|"Alain Guillemoles"|"Alain Joxe"|"Alain Morice"|"Alain Renon"|"Alain Zecchini"|"Albert Memmi"|"Alberto Manguel"|"Alex De Waal"|"Alfonso Artico"| [...])
     
     The complete list contains about 10kB. When I try to "flex" this file
     (on a Solaris 2.6 machine, using a modified flex 2.5.4 (I only increased
     some of the predefined values in flexdefs.h) I get the error:
     
     myflex/flex -8  sentag.tmp.l
     flex scanner push-back overflow
     
     When I remove the slashes in the macro definition everything works fine.
     As I understand it, the double quotes escape the slash-character so it
     really means "/" and not "trailing context". Furthermore, I tried to
     escape the slashes with backslashes, but with no use, the same error message
     appeared when flexing the code.
     
     Do you have an idea what's going on here?
     
     Greetings from Germany,
     	Georg
     --
     Georg Rehm                                     georg@cl-ki.uni-osnabrueck.de
     Institute for Semantic Information Processing, University of Osnabrueck, FRG
\end{verbatim}

\section{unnamed-faq-82}

\begin{verbatim}
To: Georg.Rehm@CL-KI.Uni-Osnabrueck.DE
     Subject: Re: "flex scanner push-back overflow"
     In-reply-to: Your message of Thu, 20 Aug 1998 09:47:54 PDT.
     Date: Thu, 20 Aug 1998 07:05:35 PDT
     From: Vern Paxson <vern>
     
     > myflex/flex -8  sentag.tmp.l
     > flex scanner push-back overflow
     
     Flex itself uses a flex scanner.  That scanner is running out of buffer
     space when it tries to unput() the humongous macro you've defined.  When
     you remove the '/'s, you make it small enough so that it fits in the buffer;
     removing spaces would do the same thing.
     
     The fix is to either rethink how come you're using such a big macro and
     perhaps there's another/better way to do it; or to rebuild flex's own
     scan.c with a larger value for
     
     	#define YY_BUF_SIZE 16384
     
     - Vern
\end{verbatim}

\section{unnamed-faq-83}

\begin{verbatim}
To: Jan Kort <jan@research.techforce.nl>
     Subject: Re: Flex
     In-reply-to: Your message of Fri, 04 Sep 1998 12:18:43 +0200.
     Date: Sat, 05 Sep 1998 00:59:49 PDT
     From: Vern Paxson <vern>
     
     > %%
     >
     > "TEST1\n"       { fprintf(stderr, "TEST1\n"); yyless(5); }
     > ^\n             { fprintf(stderr, "empty line\n"); }
     > .               { }
     > \n              { fprintf(stderr, "new line\n"); }
     >
     > %%
     > -- input ---------------------------------------
     > TEST1
     > -- output --------------------------------------
     > TEST1
     > empty line
     > ------------------------------------------------
     
     IMHO, it's not clear whether or not this is in fact a bug.  It depends
     on whether you view yyless() as backing up in the input stream, or as
     pushing new characters onto the beginning of the input stream.  Flex
     interprets it as the latter (for implementation convenience, I'll admit),
     and so considers the newline as in fact matching at the beginning of a
     line, as after all the last token scanned an entire line and so the
     scanner is now at the beginning of a new line.
     
     I agree that this is counter-intuitive for yyless(), given its
     functional description (it's less so for unput(), depending on whether
     you're unput()'ing new text or scanned text).  But I don't plan to
     change it any time soon, as it's a pain to do so.  Consequently,
     you do indeed need to use yy_set_bol() and YY_AT_BOL() to tweak
     your scanner into the behavior you desire.
     
     Sorry for the less-than-completely-satisfactory answer.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-84}

\begin{verbatim}
To: Patrick Krusenotto <krusenot@mac-info-link.de>
     Subject: Re: Problems with restarting flex-2.5.2-generated scanner
     In-reply-to: Your message of Thu, 24 Sep 1998 10:14:07 PDT.
     Date: Thu, 24 Sep 1998 23:28:43 PDT
     From: Vern Paxson <vern>
     
     > I am using flex-2.5.2 and bison 1.25 for Solaris and I am desperately
     > trying to make my scanner restart with a new file after my parser stops
     > with a parse error. When my compiler restarts, the parser always
     > receives the token after the token (in the old file!) that caused the
     > parser error.
     
     I suspect the problem is that your parser has read ahead in order
     to attempt to resolve an ambiguity, and when it's restarted it picks
     up with that token rather than reading a fresh one.  If you're using
     yacc, then the special "error" production can sometimes be used to
     consume tokens in an attempt to get the parser into a consistent state.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-85}

\begin{verbatim}
To: Henric Jungheim <junghelh@pe-nelson.com>
     Subject: Re: flex 2.5.4a
     In-reply-to: Your message of Tue, 27 Oct 1998 16:41:42 PST.
     Date: Tue, 27 Oct 1998 16:50:14 PST
     From: Vern Paxson <vern>
     
     > This brings up a feature request:  How about a command line
     > option to specify the filename when reading from stdin?  That way one
     > doesn't need to create a temporary file in order to get the "#line"
     > directives to make sense.
     
     Use -o combined with -t (per the man page description of -o).
     
     > P.S., Is there any simple way to use non-blocking IO to parse multiple
     > streams?
     
     Simple, no.
     
     One approach might be to return a magic character on EWOULDBLOCK and
     have a rule
     
     	.*<magic-character>	// put back .*, eat magic character
     
     This is off the top of my head, not sure it'll work.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-86}

\begin{verbatim}
To: "Repko, Billy D" <billy.d.repko@intel.com>
     Subject: Re: Compiling scanners
     In-reply-to: Your message of Wed, 13 Jan 1999 10:52:47 PST.
     Date: Thu, 14 Jan 1999 00:25:30 PST
     From: Vern Paxson <vern>
     
     > It appears that maybe it cannot find the lfl library.
     
     The Makefile in the distribution builds it, so you should have it.
     It's exceedingly trivial, just a main() that calls yylex() and
     a yyrap() that always returns 1.
     
     > %%
     >       \n      ++num_lines; ++num_chars;
     >       .       ++num_chars;
     
     You can't indent your rules like this - that's where the errors are coming
     from.  Flex copies indented text to the output file, it's how you do things
     like
     
     	int num_lines_seen = 0;
     
     to declare local variables.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-87}

\begin{verbatim}
To: Erick Branderhorst <Erick.Branderhorst@asml.nl>
     Subject: Re: flex input buffer
     In-reply-to: Your message of Tue, 09 Feb 1999 13:53:46 PST.
     Date: Tue, 09 Feb 1999 21:03:37 PST
     From: Vern Paxson <vern>
     
     > In the flex.skl file the size of the default input buffers is set.  Can you
     > explain why this size is set and why it is such a high number.
     
     It's large to optimize performance when scanning large files.  You can
     safely make it a lot lower if needed.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-88}

\begin{verbatim}
To: "Guido Minnen" <guidomi@cogs.susx.ac.uk>
     Subject: Re: Flex error message
     In-reply-to: Your message of Wed, 24 Feb 1999 15:31:46 PST.
     Date: Thu, 25 Feb 1999 00:11:31 PST
     From: Vern Paxson <vern>
     
     > I'm extending a larger scanner written in Flex and I keep running into
     > problems. More specifically, I get the error message:
     > "flex: input rules are too complicated (>= 32000 NFA states)"
     
     Increase the definitions in flexdef.h for:
     
     #define JAMSTATE -32766 /* marks a reference to the state that always j
     ams */
     #define MAXIMUM_MNS 31999
     #define BAD_SUBSCRIPT -32767
     
     recompile everything, and it should all work.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-90}

\begin{verbatim}
To: "Dmitriy Goldobin" <gold@ems.chel.su>
     Subject: Re: FLEX trouble
     In-reply-to: Your message of Mon, 31 May 1999 18:44:49 PDT.
     Date: Tue, 01 Jun 1999 00:15:07 PDT
     From: Vern Paxson <vern>
     
     >   I have a trouble with FLEX. Why rule "/*".*"*/" work properly,=20
     > but rule "/*"(.|\n)*"*/" don't work ?
     
     The second of these will have to scan the entire input stream (because
     "(.|\n)*" matches an arbitrary amount of any text) in order to see if
     it ends with "*/", terminating the comment.  That potentially will overflow
     the input buffer.
     
     >   More complex rule "/*"([^*]|(\*/[^/]))*"*/ give an error
     > 'unrecognized rule'.
     
     You can't use the '/' operator inside parentheses.  It's not clear
     what "(a/b)*" actually means.
     
     >   I now use workaround with state <comment>, but single-rule is
     > better, i think.
     
     Single-rule is nice but will always have the problem of either setting
     restrictions on comments (like not allowing multi-line comments) and/or
     running the risk of consuming the entire input stream, as noted above.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-91}

\begin{verbatim}
Received: from mc-qout4.whowhere.com (mc-qout4.whowhere.com [209.185.123.18])
     	by ee.lbl.gov (8.9.3/8.9.3) with SMTP id IAA05100
     	for <vern@ee.lbl.gov>; Tue, 15 Jun 1999 08:56:06 -0700 (PDT)
     Received: from Unknown/Local ([?.?.?.?]) by my-deja.com; Tue Jun 15 08:55:43 1999
     To: vern@ee.lbl.gov
     Date: Tue, 15 Jun 1999 08:55:43 -0700
     From: "Aki Niimura" <neko@my-deja.com>
     Message-ID: <KNONDOHDOBGAEAAA@my-deja.com>
     Mime-Version: 1.0
     Cc:
     X-Sent-Mail: on
     Reply-To:
     X-Mailer: MailCity Service
     Subject: A question on flex C++ scanner
     X-Sender-Ip: 12.72.207.61
     Organization: My Deja Email  (http://www.my-deja.com:80)
     Content-Type: text/plain; charset=us-ascii
     Content-Transfer-Encoding: 7bit
     
     Dear Dr. Paxon,
     
     I have been using flex for years.
     It works very well on many projects.
     Most case, I used it to generate a scanner on C language.
     However, one project I needed to generate  a scanner
     on C++ lanuage. Thanks to your enhancement, flex did
     the job.
     
     Currently, I'm working on enhancing my previous project.
     I need to deal with multiple input streams (recursive
     inclusion) in this scanner (C++).
     I did similar thing for another scanner (C) as you
     explained in your documentation.
     
     The generated scanner (C++) has necessary methods:
     - switch_to_buffer(struct yy_buffer_state *b)
     - yy_create_buffer(istream *is, int sz)
     - yy_delete_buffer(struct yy_buffer_state *b)
     
     However, I couldn't figure out how to access current
     buffer (yy_current_buffer).
     
     yy_current_buffer is a protected member of yyFlexLexer.
     I can't access it directly.
     Then, I thought yy_create_buffer() with is = 0 might
     return current stream buffer. But it seems not as far
     as I checked the source. (flex 2.5.4)
     
     I went through the Web in addition to Flex documentation.
     However, it hasn't been successful, so far.
     
     It is not my intention to bother you, but, can you
     comment about how to obtain the current stream buffer?
     
     Your response would be highly appreciated.
     
     Best regards,
     Aki Niimura
     
     --== Sent via Deja.com http://www.deja.com/ ==--
     Share what you know. Learn what you don't.
\end{verbatim}

\section{unnamed-faq-92}

\begin{verbatim}
To: neko@my-deja.com
     Subject: Re: A question on flex C++ scanner
     In-reply-to: Your message of Tue, 15 Jun 1999 08:55:43 PDT.
     Date: Tue, 15 Jun 1999 09:04:24 PDT
     From: Vern Paxson <vern>
     
     > However, I couldn't figure out how to access current
     > buffer (yy_current_buffer).
     
     Derive your own subclass from yyFlexLexer.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-93}

\begin{verbatim}
To: "Stones, Darren" <Darren.Stones@nectech.co.uk>
     Subject: Re: You're the man to see?
     In-reply-to: Your message of Wed, 23 Jun 1999 11:10:29 PDT.
     Date: Wed, 23 Jun 1999 09:01:40 PDT
     From: Vern Paxson <vern>
     
     > I hope you can help me.  I am using Flex and Bison to produce an interpreted
     > language.  However all goes well until I try to implement an IF statement or
     > a WHILE.  I cannot get this to work as the parser parses all the conditions
     > eg. the TRUE and FALSE conditons to check for a rule match.  So I cannot
     > make a decision!!
     
     You need to use the parser to build a parse tree (= abstract syntax trwee),
     and when that's all done you recursively evaluate the tree, binding variables
     to values at that time.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-94}

\begin{verbatim}
To: Petr Danecek <petr@ics.cas.cz>
     Subject: Re: flex - question
     In-reply-to: Your message of Mon, 28 Jun 1999 19:21:41 PDT.
     Date: Fri, 02 Jul 1999 16:52:13 PDT
     From: Vern Paxson <vern>
     
     > file, it takes an enormous amount of time. It is funny, because the
     > source code has only 12 rules!!! I think it looks like an exponencial
     > growth.
     
     Right, that's the problem - some patterns (those with a lot of
     ambiguity, where yours has because at any given time the scanner can
     be in the middle of all sorts of combinations of the different
     rules) blow up exponentially.
     
     For your rules, there is an easy fix.  Change the ".*" that comes fater
     the directory name to "[^ ]*".  With that in place, the rules are no
     longer nearly so ambiguous, because then once one of the directories
     has been matched, no other can be matched (since they all require a
     leading blank).
     
     If that's not an acceptable solution, then you can enter a start state
     to pick up the .*\n after each directory is matched.
     
     Also note that for speed, you'll want to add a ".*" rule at the end,
     otherwise rules that don't match any of the patterns will be matched
     very slowly, a character at a time.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-95}

\begin{verbatim}
To: Tielman Koekemoer <tielman@spi.co.za>
     Subject: Re: Please help.
     In-reply-to: Your message of Thu, 08 Jul 1999 13:20:37 PDT.
     Date: Thu, 08 Jul 1999 08:20:39 PDT
     From: Vern Paxson <vern>
     
     > I was hoping you could help me with my problem.
     >
     > I tried compiling (gnu)flex on a Solaris 2.4 machine
     > but when I ran make (after configure) I got an error.
     >
     > --------------------------------------------------------------
     > gcc -c -I. -I. -g -O parse.c
     > ./flex -t -p  ./scan.l >scan.c
     > sh: ./flex: not found
     > *** Error code 1
     > make: Fatal error: Command failed for target `scan.c'
     > -------------------------------------------------------------
     >
     > What's strange to me is that I'm only
     > trying to install flex now. I then edited the Makefile to
     > and changed where it says "FLEX = flex" to "FLEX = lex"
     > ( lex: the native Solaris one ) but then it complains about
     > the "-p" option. Is there any way I can compile flex without
     > using flex or lex?
     >
     > Thanks so much for your time.
     
     You managed to step on the bootstrap sequence, which first copies
     initscan.c to scan.c in order to build flex.  Try fetching a fresh
     distribution from ftp.ee.lbl.gov.  (Or you can first try removing
     ".bootstrap" and doing a make again.)
     
     		Vern
\end{verbatim}

\section{unnamed-faq-96}

\begin{verbatim}
To: Tielman Koekemoer <tielman@spi.co.za>
     Subject: Re: Please help.
     In-reply-to: Your message of Fri, 09 Jul 1999 09:16:14 PDT.
     Date: Fri, 09 Jul 1999 00:27:20 PDT
     From: Vern Paxson <vern>
     
     > First I removed .bootstrap (and ran make) - no luck. I downloaded the
     > software but I still have the same problem. Is there anything else I
     > could try.
     
     Try:
     
     	cp initscan.c scan.c
     	touch scan.c
     	make scan.o
     
     If this last tries to first build scan.c from scan.l using ./flex, then
     your "make" is broken, in which case compile scan.c to scan.o by hand.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-97}

\begin{verbatim}
To: Sumanth Kamenani <skamenan@crl.nmsu.edu>
     Subject: Re: Error
     In-reply-to: Your message of Mon, 19 Jul 1999 23:08:41 PDT.
     Date: Tue, 20 Jul 1999 00:18:26 PDT
     From: Vern Paxson <vern>
     
     > I am getting a compilation error. The error is given as "unknown symbol- yylex".
     
     The parser relies on calling yylex(), but you're instead using the C++ scanning
     class, so you need to supply a yylex() "glue" function that calls an instance
     scanner of the scanner (e.g., "scanner->yylex()").
     
     		Vern
\end{verbatim}

\section{unnamed-faq-98}

\begin{verbatim}
To: daniel@synchrods.synchrods.COM (Daniel Senderowicz)
     Subject: Re: lex
     In-reply-to: Your message of Mon, 22 Nov 1999 11:19:04 PST.
     Date: Tue, 23 Nov 1999 15:54:30 PST
     From: Vern Paxson <vern>
     
     Well, your problem is the
     
     switch (yybgin-yysvec-1) {      /* witchcraft */
     
     at the beginning of lex rules.  "witchcraft" == "non-portable".  It's
     assuming knowledge of the AT&T lex's internal variables.
     
     For flex, you can probably do the equivalent using a switch on YYSTATE.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-99}

\begin{verbatim}
To: archow@hss.hns.com
     Subject: Re: Regarding distribution of flex and yacc based grammars
     In-reply-to: Your message of Sun, 19 Dec 1999 17:50:24 +0530.
     Date: Wed, 22 Dec 1999 01:56:24 PST
     From: Vern Paxson <vern>
     
     > When we provide the customer with an object code distribution, is it
     > necessary for us to provide source
     > for the generated C files from flex and bison since they are generated by
     > flex and bison ?
     
     For flex, no.  I don't know what the current state of this is for bison.
     
     > Also, is there any requrirement for us to neccessarily  provide source for
     > the grammar files which are fed into flex and bison ?
     
     Again, for flex, no.
     
     See the file "COPYING" in the flex distribution for the legalese.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-100}

\begin{verbatim}
To: Martin Gallwey <gallweym@hyperion.moe.ul.ie>
     Subject: Re: Flex, and self referencing rules
     In-reply-to: Your message of Sun, 20 Feb 2000 01:01:21 PST.
     Date: Sat, 19 Feb 2000 18:33:16 PST
     From: Vern Paxson <vern>
     
     > However, I do not use unput anywhere. I do use self-referencing
     > rules like this:
     >
     > UnaryExpr               ({UnionExpr})|("-"{UnaryExpr})
     
     You can't do this - flex is *not* a parser like yacc (which does indeed
     allow recursion), it is a scanner that's confined to regular expressions.
     
     		Vern
\end{verbatim}

\section{unnamed-faq-101}

\begin{verbatim}
To: slg3@lehigh.edu (SAMUEL L. GULDEN)
     Subject: Re: Flex problem
     In-reply-to: Your message of Thu, 02 Mar 2000 12:29:04 PST.
     Date: Thu, 02 Mar 2000 23:00:46 PST
     From: Vern Paxson <vern>
     
     If this is exactly your program:
     
     > digit [0-9]
     > digits {digit}+
     > whitespace [ \t\n]+
     >
     > %%
     > "[" { printf("open_brac\n");}
     > "]" { printf("close_brac\n");}
     > "+" { printf("addop\n");}
     > "*" { printf("multop\n");}
     > {digits} { printf("NUMBER = %s\n", yytext);}
     > whitespace ;
     
     then the problem is that the last rule needs to be "{whitespace}" !
     
     		Vern
\end{verbatim}

\section{What is the difference between YYLEX\_{}PARAM and YY\_{}DECL?}


YYLEX\_{}PARAM is not a flex symbol. It is for Bison. It tells Bison to pass extra
params when it calls yylex() from the parser.

YY\_{}DECL is the Flex declaration of yylex. The default is similar to this:
\begin{verbatim}
#define int yy_lex ()
\end{verbatim}

\section{Why do I get "conflicting types for yylex" error?}


This is a compiler error regarding a generated Bison parser, not a Flex scanner. 
It means you need a prototype of yylex() in the top of the Bison file. 
Be sure the prototype matches YY\_{}DECL.
\section{How do I access the values set in a Flex action from within a Bison action?}


With \${}1, \${}2, \${}3, etc. These are called "Semantic Values" in the Bison manual. 
SeeTop.
\chapter{Appendix A Appendices}

\begin{itemize}
\item Makefiles and Flex
\item Bison Bridge
\item M4 Dependency
\item Common Patterns
\end{itemize}

\section{A.1 Makefiles and Flex}


In this appendix, we provide tips for writing Makefiles to build your scanners.

In a traditional build environment, we say that thefiles are the
sources, and thefiles are the intermediate files. When using \verb`flex` , however, thefiles are the sources, and the generatedfiles (along with thefiles) are the intermediate files. 
This requires you to carefully plan your Makefile.

Modernprograms understand thatis intended to
generateor, and will behave
accordingly.  The
following Makefile does not explicitly instructhow to buildfrom. Instead, it relies on the implicit rules of theprogram to build the intermediate file,:


\begin{verbatim}
# Basic Makefile -- relies on implicit rules
         # Creates "myprogram" from "scan.l" and "myprogram.c"
         #
         LEX=flex
         myprogram: scan.o myprogram.o
         scan.o: scan.l
\end{verbatim}


For simple cases, the above may be sufficient. For other cases,
you may have to explicitly instructhow to build your scanner. 
The following is an example of a Makefile containing explicit rules:


\begin{verbatim}
# Basic Makefile -- provides explicit rules
         # Creates "myprogram" from "scan.l" and "myprogram.c"
         #
         LEX=flex
         myprogram: scan.o myprogram.o
                 $(CC) -o $@  $(LDFLAGS) $^
     
         myprogram.o: myprogram.c
                 $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $^
     
         scan.o: scan.c
                 $(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $^
     
         scan.c: scan.l
                 $(LEX) $(LFLAGS) -o $@ $^
     
         clean:
                 $(RM) *.o scan.c
\end{verbatim}


Notice in the above example thatis in the \verb`clean` target. 
This is because we consider the fileto be an intermediate file.

Finally, we provide a realistic example of a \verb`flex` scanner used with a \verb`bison` parser. 
There is a tricky problem we have to deal with. Since a \verb`flex` scanner
will typically include a header file (e.g.,) generated by the
parser, we need to be sure that the header file is generated BEFORE the scanner
is compiled. We handle this case in the following example:
\begin{verbatim}
# Makefile example -- scanner and parser.
         # Creates "myprogram" from "scan.l", "parse.y", and "myprogram.c"
         #
         LEX     = flex
         YACC    = bison -y
         YFLAGS  = -d
         objects = scan.o parse.o myprogram.o
     
         myprogram: $(objects)
         scan.o: scan.l parse.c
         parse.o: parse.y
         myprogram.o: myprogram.c
\end{verbatim}


In the above example, notice the line,
\begin{verbatim}
scan.o: scan.l parse.c
\end{verbatim}


, which lists the file(the generated parser) as a dependency of. We want to ensure that the parser is created before the scanner
is compiled, and the above line seems to do the trick. Feel free to experiment
with your specific implementation of.

For more details on writing Makefiles, seeTop.

1GNUand GNUare two such
programs that provide implicit rules for flex-generated scanners.

2GNUmay generate code to execute flex in lex-compatible mode, or to stdout. If this is not what you want,
then you should provide an explicit rule in your Makefile.am

3This example also applies to yacc parsers.
\section{A.2 C Scanners with Bison Parsers}


This section describes the \verb`flex` features useful when integrating \verb`flex` with \verb`GNU bison` . 
Skip this section if you are not using \verb`bison` with your scanner.  Here we discuss only the \verb`flex` half of the \verb`flex` and \verb`bison` pair.  We do not discuss \verb`bison` in any detail.  For more information about generating \verb`bison` parsers, seeTop.

A compatible \verb`bison` scanner is generated by declaring ‘\verb`%option bison-bridge`’ or by supplying ‘\verb`--bison-bridge`’ when invoking \verb`flex` from the command line.  This instructs \verb`flex` that the macro \verb`yylval` may be used. The data type for \verb`yylval` , \verb`YYSTYPE` ,
is typically defined in a header file, included in section 1 of the \verb`flex` input file.  For a list of functions and macros
available, Seebison-functions.

The declaration of yylex becomes,


\begin{verbatim}
int yylex ( YYSTYPE * lvalp, yyscan_t scanner );
\end{verbatim}


If \verb`%option bison-locations` is specified, then the declaration
becomes,


\begin{verbatim}
int yylex ( YYSTYPE * lvalp, YYLTYPE * llocp, yyscan_t scanner );
\end{verbatim}


Note that the macros \verb`yylval` and \verb`yylloc` evaluate to pointers. 
Support for \verb`yylloc` is optional in \verb`bison` , so it is optional in \verb`flex` as well. The following is an example of a \verb`flex` scanner that
is compatible with \verb`bison` .


\begin{verbatim}
/* Scanner for "C" assignment statements... sort of. */
         %{
         #include "y.tab.h"  /* Generated by bison. */
         %}
     
         %option bison-bridge bison-locations
         %%
     
         [[:digit:]]+  { yylval->num = atoi(yytext);   return NUMBER;}
         [[:alnum:]]+  { yylval->str = strdup(yytext); return STRING;}
         "="|";"       { return yytext[0];}
         .  {}
         %%
\end{verbatim}


As you can see, there really is no magic here. We just use \verb`yylval` as we would any other variable. The data type of \verb`yylval` is generated by \verb`bison` , and included in the file. Here is the corresponding \verb`bison` parser:


\begin{verbatim}
/* Parser to convert "C" assignments to lisp. */
         %{
         /* Pass the argument to yyparse through to yylex. */
         #define YYPARSE_PARAM scanner
         #define YYLEX_PARAM   scanner
         %}
         %locations
         %pure_parser
         %union {
             int num;
             char* str;
         }
         %token <str> STRING
         %token <num> NUMBER
         %%
         assignment:
             STRING '=' NUMBER ';' {
                 printf( "(setf %s %d)", $1, $3 );
            }
         ;
\end{verbatim}


1The features described here are
purely optional, and are by no means the only way to use flex with bison. 
We merely provide some glue to ease development of your parser-scanner pair.
\section{A.3 M4 Dependency}


The macro processor \verb`m4` must be installed wherever flex is installed. \verb`flex` invokes ‘\verb`m4`’, found by searching the directories in the \verb`PATH` environment variable. Any code you place in section 1 or in the
actions will be sent through m4. Please follow these rules to protect your
code from unwanted \verb`m4` processing.
\begin{itemize}
\item Do not use symbols that begin with, ‘\verb`m4_`’, such as, ‘\verb`m4_define`’,
or ‘\verb`m4_include`’, since those are reserved for \verb`m4` macro names. If for
some reason you need m4\_{} as a prefix, use a preprocessor \#{}define to get your
symbol past m4 unmangled.
\item Do not use the strings ‘\verb`[[`’ or ‘\verb`]]`’ anywhere in your code. The
former is not valid in C, except within comments and strings, but the latter is valid in
code such as \verb`x[y[z]]` . The solution is simple. To get the literal string \verb`"]]"` , use \verb`"]""]"` . To get the array notation \verb`x[y[z]]` ,
use \verb`x[y[z] ]` . Flex will attempt to detect these sequences in user code, and
escape them. However, it's best to avoid this complexity where possible, by
removing such sequences from your code.
\end{itemize}


 \verb`m4` is only required at the time you run \verb`flex` . The generated
scanner is ordinary C or C++, and doesrequire \verb`m4` .

1The use of m4 is subject to change in
future revisions of flex. It is not part of the public API of flex. Do not depend on it.
\section{A.4 Common Patterns}


This appendix provides examples of common regular expressions you might use
in your scanner.
\begin{itemize}
\item Numbers
\item Identifiers
\item Quoted Constructs
\item Addresses
\end{itemize}



Next:Identifiers,
Up:Common Patterns \verb`([[:digit:]]{-}[0])[[:digit:]]*`  \verb`0[xX][[:xdigit:]]+`  \verb`0[01234567]*` 
\begin{verbatim}
{dseq}      ([[:digit:]]+)
      {dseq_opt}  ([[:digit:]]*)
      {frac}      (({dseq_opt}"."{dseq})|{dseq}".")
      {exp}       ([eE][+-]?{dseq})
      {exp_opt}   ({exp}?)
      {fsuff}     [flFL]
      {fsuff_opt} ({fsuff}?)
      {hpref}     (0[xX])
      {hdseq}     ([[:xdigit:]]+)
      {hdseq_opt} ([[:xdigit:]]*)
      {hfrac}     (({hdseq_opt}"."{hdseq})|({hdseq}"."))
      {bexp}      ([pP][+-]?{dseq})
      {dfc}       (({frac}{exp_opt}{fsuff_opt})|({dseq}{exp}{fsuff_opt}))
      {hfc}       (({hpref}{hfrac}{bexp}{fsuff_opt})|({hpref}{hdseq}{bexp}{fsuff_opt}))
     
      {c99_floating_point_constant}  ({dfc}|{hfc})
\end{verbatim}


See C99 section 6.4.4.2 for the gory details.


Next:Quoted Constructs,
Previous:Numbers,
Up:Common Patterns
\begin{verbatim}
ucn        ((\\u([[:xdigit:]]{4}))|(\\U([[:xdigit:]]{8})))
     nondigit    [_[:alpha:]]
     c99_id     ([_[:alpha:]]|{ucn})([_[:alnum:]]|{ucn})*
\end{verbatim}


Technically, the above pattern does not encompass all possible C99 identifiers, since C99 allows for
"implementation-defined" characters. In practice, C compilers follow the above pattern, with the
addition of the ‘\verb`$`’ character.
\begin{verbatim}
[\x09\x0A\x0D\x20-\x7E]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF]([\x80-\xBF]{2})|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF]([\x80-\xBF]{2})|[\xF1-\xF3]([\x80-\xBF]{3})|\xF4[\x80-\x8F]([\x80-\xBF]{2})
\end{verbatim}



Next:Addresses,
Previous:Identifiers,
Up:Common Patterns \verb`L?\"([^\"\\\n]|(\\['\"?\\abfnrtv])|(\\([0123456]{1,3}))|(\\x[[:xdigit:]]+)|(\\u([[:xdigit:]]{4}))|(\\U([[:xdigit:]]{8})))*\"`  \verb`("/*"([^*]|"*"[^/])*"*/")|("/"(\\\n)*"/"[^\n]*)` 

Note that in C99, a ‘\verb`//`’-style comment may be split across lines,  and, contrary to popular belief,
does not include the trailing ‘\verb`\n`’ character.

A better way to scan ‘\verb`/* */`’ comments is by line, rather than matching
possibly huge comments all at once. This will allow you to scan comments of
unlimited length, as long as line breaks appear at sane intervals. This is also
more efficient when used with automatic line number processing. Seeoption-yylineno.
\begin{verbatim}
<INITIAL>{
         "/*"      BEGIN(COMMENT);
     }
     <COMMENT>{
         "*/"      BEGIN(0);
         [^*\n]+   ;
         "*"[^/]   ;
         \n        ;
     }
\end{verbatim}



Previous:Quoted Constructs,
Up:Common Patterns
\begin{verbatim}
dec-octet     [0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]
     IPv4address   {dec-octet}\.{dec-octet}\.{dec-octet}\.{dec-octet}
\end{verbatim}

\begin{verbatim}
h16           [0-9A-Fa-f]{1,4}
     ls32          {h16}:{h16}|{IPv4address}
     IPv6address   ({h16}:){6}{ls32}|
                   ::({h16}:){5}{ls32}|
                   ({h16})?::({h16}:){4}{ls32}|
                   (({h16}:){0,1}{h16})?::({h16}:){3}{ls32}|
                   (({h16}:){0,2}{h16})?::({h16}:){2}{ls32}|
                   (({h16}:){0,3}{h16})?::{h16}:{ls32}|
                   (({h16}:){0,4}{h16})?::{ls32}|
                   (({h16}:){0,5}{h16})?::{h16}|
                   (({h16}:){0,6}{h16})?::
\end{verbatim}


SeeRFC 2373for details. 
Note that you have to fold the definition of \verb`IPv6address` into one
line and that it also matches the “unspecified address” “::”. \verb`(([^:/?#]+):)?("//"([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?` 

This pattern is nearly useless, since it allows just about any character
to appear in a URI, including spaces and control characters.  SeeRFC 2396for details.
\chapter{Indices}

\begin{itemize}
\item Concept Index
\item Index of Functions and Macros
\item Index of Variables
\item Index of Data Types
\item Index of Hooks
\item Index of Scanner Options
\end{itemize}

\section{Concept Index}

\begin{itemize}
\item \${} as normal character in patterns:Patterns
\item \%{}array, advantages of:Matching
\item \%{}array, use of:Matching
\item \%{}array, with C++:Matching
\item \%{}option noyywrapp:Generated Scanner
\item \%{}pointer, and unput():Actions
\item \%{}pointer, use of:Matching
\item \%{}top:Definitions Section
\item \%{}\{{} and \%{}\}{}, in Definitions Section:Definitions Section
\item \%{}\{{} and \%{}\}{}, in Rules Section:Actions
\item <<EOF>>, use of:EOF
\item [] in patterns:Patterns
\item \^{} as non-special character in patterns:Patterns
\item accessor functions, use of:Accessor Methods
\item actions:Actions
\item actions, embedded C strings:Actions
\item actions, redefining YY\_{}BREAK:Misc Macros
\item actions, use of \{{} and \}{}:Actions
\item aliases, how to define:Definitions Section
\item arguments, command-line:Scanner Options
\item array, default size for yytext:User Values
\item backing up, eliminating:Performance
\item backing up, eliminating by adding error rules:Performance
\item backing up, eliminating with catch-all rule:Performance
\item backing up, example of eliminating:Performance
\item BEGIN:Actions
\item BEGIN, explanation:Start Conditions
\item beginning of line, in patterns:Patterns
\item bison, bridging with flex:Bison Bridge
\item bison, parser:Bison Bridge
\item bison, scanner to be called from bison:Bison Bridge
\item BOL, checking the BOL flag:Misc Macros
\item BOL, in patterns:Patterns
\item BOL, setting it:Misc Macros
\item braces in patterns:Patterns
\item bugs, reporting:Reporting Bugs
\item C code in flex input:Definitions Section
\item C++:Cxx
\item C++ and \%{}array:User Values
\item C++ I/O, customizing:How do I use my own I/O classes in a C++ scanner?
\item C++ scanners, including multiple scanners:Cxx
\item C++ scanners, use of:Cxx
\item c++, experimental form of scanner class:Cxx
\item C++, multiple different scanners:Cxx
\item C-strings, in actions:Actions
\item case-insensitive, effect on character classes:Patterns
\item character classes in patterns:Patterns
\item character classes in patterns, syntax of:Patterns
\item character classes, equivalence of:Patterns
\item clearing an input buffer:Multiple Input Buffers
\item command-line options:Scanner Options
\item comments in flex input:Definitions Section
\item comments in the input:Comments in the Input
\item comments, discarding:Actions
\item comments, example of scanning C comments:Start Conditions
\item comments, in actions:Actions
\item comments, in rules section:Comments in the Input
\item comments, syntax of:Comments in the Input
\item comments, valid uses of:Comments in the Input
\item compressing whitespace:Actions
\item concatenation, in patterns:Patterns
\item copyright of flex:Copyright
\item counting characters and lines:Simple Examples
\item customizing I/O in C++ scanners:How do I use my own I/O classes in a C++ scanner?
\item default rule:Matching
\item default rule:Simple Examples
\item defining pattern aliases:Definitions Section
\item Definitions, in flex input:Definitions Section
\item deleting lines from input:Actions
\item discarding C comments:Actions
\item distributing flex:Copyright
\item ECHO:Actions
\item ECHO, and yyout:Generated Scanner
\item embedding C code in flex input:Definitions Section
\item end of file, in patterns:Patterns
\item end of line, in negated character classes:Patterns
\item end of line, in patterns:Patterns
\item end-of-file, and yyrestart():Generated Scanner
\item EOF and yyrestart():Generated Scanner
\item EOF in patterns, syntax of:Patterns
\item EOF, example using multiple input buffers:Multiple Input Buffers
\item EOF, explanation:EOF
\item EOF, pushing back:Actions
\item EOL, in negated character classes:Patterns
\item EOL, in patterns:Patterns
\item error messages, end of buffer missed:Lex and Posix
\item error reporting, diagnostic messages:Diagnostics
\item error reporting, in C++:Cxx
\item error rules, to eliminate backing up:Performance
\item escape sequences in patterns, syntax of:Patterns
\item exiting with yyterminate():Actions
\item experimental form of c++ scanner class:Cxx
\item extended scope of start conditions:Start Conditions
\item file format:Format
\item file format, serialized tables:Tables File Format
\item flushing an input buffer:Multiple Input Buffers
\item flushing the internal buffer:Actions
\item format of flex input:Format
\item format of input file:Format
\item freeing tables:Loading and Unloading Serialized Tables
\item getting current start state with YY\_{}START:Start Conditions
\item halting with yyterminate():Actions
\item handling include files with multiple input buffers:Multiple Input Buffers
\item header files, with C++:Cxx
\item include files, with C++:Cxx
\item input file, Definitions section:Definitions Section
\item input file, Rules Section:Rules Section
\item input file, user code Section:User Code Section
\item input():Actions
\item input(), and C++:Actions
\item input, format of:Format
\item input, matching:Matching
\item keywords, for performance:Performance
\item lex (traditional) and POSIX:Lex and Posix
\item LexerInput, overriding:How do I use my own I/O classes in a C++ scanner?
\item LexerOutput, overriding:How do I use my own I/O classes in a C++ scanner?
\item limitations of flex:Limitations
\item literal text in patterns, syntax of:Patterns
\item loading tables at runtime:Loading and Unloading Serialized Tables
\item m4:M4 Dependency
\item Makefile, example of implicit rules:Makefiles and Flex
\item Makefile, explicit example:Makefiles and Flex
\item Makefile, syntax:Makefiles and Flex
\item matching C-style double-quoted strings:Start Conditions
\item matching, and trailing context:Matching
\item matching, length of:Matching
\item matching, multiple matches:Matching
\item member functions, C++:Cxx
\item memory management:Memory Management
\item memory, allocating input buffers:Multiple Input Buffers
\item memory, considerations for reentrant scanners:Init and Destroy Functions
\item memory, deleting input buffers:Multiple Input Buffers
\item memory, for start condition stacks:Start Conditions
\item memory, serialized tables:Loading and Unloading Serialized Tables
\item memory, serialized tables:Serialized Tables
\item methods, c++:Cxx
\item minimal scanner:Matching
\item multiple input streams:Multiple Input Buffers
\item name definitions, not POSIX:Lex and Posix
\item negating ranges in patterns:Patterns
\item newline, matching in patterns:Patterns
\item non-POSIX features of flex:Lex and Posix
\item noyywrap, \%{}option:Generated Scanner
\item NULL character in patterns, syntax of:Patterns
\item octal characters in patterns:Patterns
\item options, command-line:Scanner Options
\item overriding LexerInput:How do I use my own I/O classes in a C++ scanner?
\item overriding LexerOutput:How do I use my own I/O classes in a C++ scanner?
\item overriding the memory routines:Overriding The Default Memory Management
\item Pascal-like language:Simple Examples
\item pattern aliases, defining:Definitions Section
\item pattern aliases, expansion of:Patterns
\item pattern aliases, how to define:Definitions Section
\item pattern aliases, use of:Definitions Section
\item patterns and actions on different lines:Lex and Posix
\item patterns, character class equivalence:Patterns
\item patterns, common:Common Patterns
\item patterns, end of line:Patterns
\item patterns, grouping and precedence:Patterns
\item patterns, in rules section:Patterns
\item patterns, invalid trailing context:Patterns
\item patterns, matching:Matching
\item patterns, precedence of operators:Patterns
\item patterns, repetitions with grouping:Patterns
\item patterns, special characters treated as non-special:Patterns
\item patterns, syntax:Patterns
\item patterns, tuning for performance:Performance
\item patterns, valid character classes:Patterns
\item performance optimization, matching longer tokens:Performance
\item performance optimization, recognizing keywords:Performance
\item performance, backing up:Performance
\item performance, considerations:Performance
\item performance, using keywords:Performance
\item popping an input buffer:Multiple Input Buffers
\item POSIX and lex:Lex and Posix
\item POSIX comp;compliance:Lex and Posix
\item POSIX, character classes in patterns, syntax of:Patterns
\item preprocessor macros, for use in actions:Actions
\item pushing an input buffer:Multiple Input Buffers
\item pushing back characters with unput:Actions
\item pushing back characters with unput():Actions
\item pushing back characters with yyless:Actions
\item pushing back EOF:Actions
\item ranges in patterns:Patterns
\item ranges in patterns, negating:Patterns
\item recognizing C comments:Start Conditions
\item reentrant scanners, multiple interleaved scanners:Reentrant Uses
\item reentrant scanners, recursive invocation:Reentrant Uses
\item reentrant, accessing flex variables:Global Replacement
\item reentrant, accessor functions:Accessor Methods
\item reentrant, API explanation:Reentrant Overview
\item reentrant, calling functions:Extra Reentrant Argument
\item reentrant, example of:Reentrant Example
\item reentrant, explanation:Reentrant
\item reentrant, extra data:Extra Data
\item reentrant, initialization:Init and Destroy Functions
\item regular expressions, in patterns:Patterns
\item REJECT:Actions
\item REJECT, calling multiple times:Actions
\item REJECT, performance costs:Performance
\item reporting bugs:Reporting Bugs
\item restarting the scanner:Lex and Posix
\item RETURN, within actions:Generated Scanner
\item rules, default:Simple Examples
\item rules, in flex input:Rules Section
\item scanner, definition of:Introduction
\item sections of flex input:Format
\item serialization:Serialized Tables
\item serialization of tables:Creating Serialized Tables
\item serialized tables, multiple scanners:Creating Serialized Tables
\item stack, input buffer pop:Multiple Input Buffers
\item stack, input buffer push:Multiple Input Buffers
\item stacks, routines for manipulating:Start Conditions
\item start condition, applying to multiple patterns:Start Conditions
\item start conditions:Start Conditions
\item start conditions, behavior of default rule:Start Conditions
\item start conditions, exclusive:Start Conditions
\item start conditions, for different interpretations of same input:Start Conditions
\item start conditions, in patterns:Patterns
\item start conditions, inclusive:Start Conditions
\item start conditions, inclusive v.s. exclusive:Start Conditions
\item start conditions, integer values:Start Conditions
\item start conditions, multiple:Start Conditions
\item start conditions, special wildcard condition:Start Conditions
\item start conditions, use of a stack:Start Conditions
\item start conditions, use of wildcard condition (<*>):Start Conditions
\item start conditions, using BEGIN:Start Conditions
\item stdin, default for yyin:Generated Scanner
\item stdout, as default for yyout:Generated Scanner
\item strings, scanning strings instead of files:Multiple Input Buffers
\item tables, creating serialized:Creating Serialized Tables
\item tables, file format:Tables File Format
\item tables, freeing:Loading and Unloading Serialized Tables
\item tables, loading and unloading:Loading and Unloading Serialized Tables
\item terminating with yyterminate():Actions
\item token:Matching
\item trailing context, in patterns:Patterns
\item trailing context, limits of:Patterns
\item trailing context, matching:Matching
\item trailing context, performance costs:Performance
\item trailing context, variable length:Performance
\item unput():Actions
\item unput(), and \%{}pointer:Actions
\item unput(), pushing back characters:Actions
\item user code, in flex input:User Code Section
\item username expansion:Simple Examples
\item using integer values of start condition names:Start Conditions
\item verbatim text in patterns, syntax of:Patterns
\item warning, dangerous trailing context:Limitations
\item warning, rule cannot be matched:Diagnostics
\item warnings, diagnostic messages:Diagnostics
\item whitespace, compressing:Actions
\item yacc interface:Yacc
\item yacc, interface:Yacc
\item YY\_{}CURRENT\_{}BUFFER, and multiple buffers Finally, the macro:Multiple Input Buffers
\item YY\_{}EXTRA\_{}TYPE, defining your own type:Extra Data
\item YY\_{}FLUSH\_{}BUFFER:Actions
\item YY\_{}INPUT:Generated Scanner
\item YY\_{}INPUT, overriding:Generated Scanner
\item YY\_{}START, example:Start Conditions
\item YY\_{}USER\_{}ACTION to track each time a rule is matched:Misc Macros
\item yyalloc, overriding:Overriding The Default Memory Management
\item yyfree, overriding:Overriding The Default Memory Management
\item yyin:Generated Scanner
\item yyinput():Actions
\item yyleng:Matching
\item yyleng, modification of:Actions
\item yyless():Actions
\item yyless(), pushing back characters:Actions
\item yylex(), in generated scanner:Generated Scanner
\item yylex(), overriding:Generated Scanner
\item yylex, overriding the prototype of:Generated Scanner
\item yylineno, in a reentrant scanner:Reentrant Functions
\item yylineno, performance costs:Performance
\item yymore():Actions
\item yymore() to append token to previous token:Actions
\item yymore(), mega-kludge:Actions
\item yymore, and yyleng:Actions
\item yymore, performance penalty of:Actions
\item yyout:Generated Scanner
\item yyrealloc, overriding:Overriding The Default Memory Management
\item yyrestart():Generated Scanner
\item yyterminate():Actions
\item yytext:Matching
\item yytext, default array size:User Values
\item yytext, memory considerations:A Note About yytext And Memory
\item yytext, modification of:Actions
\item yytext, two types of:Matching
\item yywrap():Generated Scanner
\item yywrap, default for:Generated Scanner
\item |, in actions:Actions
\item |, use of:Actions
\end{itemize}

\section{Index of Functions and Macros}


This is an index of functions and preprocessor macros that look like functions. 
For macros that expand to variables or constants, seeIndex of Variables.
\begin{itemize}
\item  \verb`BEGIN` :Start Conditions
\item  \verb`debug (C++ only)` :Cxx
\item  \verb`LexerError (C++ only)` :Cxx
\item  \verb`LexerInput (C++ only)` :Cxx
\item  \verb`LexerOutput (C++ only)` :Cxx
\item  \verb`lineno (C++ only)` :Cxx
\item  \verb`set_debug (C++ only)` :Cxx
\item  \verb`switch_streams (C++ only)` :Cxx
\item  \verb`YY_AT_BOL` :Misc Macros
\item  \verb`yy_create_buffer` :Multiple Input Buffers
\item  \verb`yy_delete_buffer` :Multiple Input Buffers
\item  \verb`yy_flush_buffer` :Multiple Input Buffers
\item  \verb`yy_new_buffer` :Multiple Input Buffers
\item  \verb`YY_NEW_FILE  (now obsolete)` :EOF
\item  \verb`yy_pop_state` :Start Conditions
\item  \verb`yy_push_state` :Start Conditions
\item  \verb`yy_scan_buffer` :Multiple Input Buffers
\item  \verb`yy_scan_bytes` :Multiple Input Buffers
\item  \verb`yy_scan_string` :Multiple Input Buffers
\item  \verb`yy_set_bol` :Misc Macros
\item  \verb`yy_set_interactive` :Misc Macros
\item  \verb`yy_switch_to_buffer` :Multiple Input Buffers
\item  \verb`yy_top_state` :Start Conditions
\item  \verb`yyFlexLexer constructor (C++ only)` :Cxx
\item  \verb`yyget_debug` :Reentrant Functions
\item  \verb`yyget_extra` :Reentrant Functions
\item  \verb`yyget_extra` :Extra Data
\item  \verb`yyget_in` :Reentrant Functions
\item  \verb`yyget_leng` :Reentrant Functions
\item  \verb`yyget_lineno` :Reentrant Functions
\item  \verb`yyget_out` :Reentrant Functions
\item  \verb`yyget_text` :Reentrant Functions
\item  \verb`YYLeng (C++ only)` :Cxx
\item  \verb`yylex (C++ version)` :Cxx
\item  \verb`yylex (reentrant version)` :Bison Bridge
\item  \verb`yylex_destroy` :Init and Destroy Functions
\item  \verb`yylex_init` :Init and Destroy Functions
\item  \verb`yypop_buffer_state` :Multiple Input Buffers
\item  \verb`yypush_buffer_state` :Multiple Input Buffers
\item  \verb`yyrestart` :User Values
\item  \verb`yyset_debug` :Reentrant Functions
\item  \verb`yyset_extra` :Reentrant Functions
\item  \verb`yyset_extra` :Extra Data
\item  \verb`yyset_in` :Reentrant Functions
\item  \verb`yyset_lineno` :Reentrant Functions
\item  \verb`yyset_out` :Reentrant Functions
\item  \verb`yytables_destroy` :Loading and Unloading Serialized Tables
\item  \verb`yytables_fload` :Loading and Unloading Serialized Tables
\item  \verb`YYText (C++ only)` :Cxx
\end{itemize}

\section{Index of Variables}


This is an index of variables, constants, and preprocessor macros
that expand to variables or constants.
\begin{itemize}
\item  \verb`INITIAL` :Start Conditions
\item  \verb`YY_CURRENT_BUFFER` :User Values
\item  \verb`YY_END_OF_BUFFER_CHAR` :Multiple Input Buffers
\item  \verb`YY_NUM_RULES` :Misc Macros
\item  \verb`YY_START` :User Values
\item  \verb`YY_START` :Start Conditions
\item  \verb`yyextra` :Extra Data
\item  \verb`yyin` :User Values
\item  \verb`yyleng` :User Values
\item  \verb`yylloc` :Bison Bridge
\item  \verb`YYLMAX` :User Values
\item  \verb`yylval` :Bison Bridge
\item  \verb`yylval, with yacc` :Yacc
\item  \verb`yyout` :User Values
\item  \verb`yyscanner (reentrant only)` :Extra Reentrant Argument
\item  \verb`yytext` :User Values
\item  \verb`yytext` :Matching
\end{itemize}

\section{Index of Data Types}

\begin{itemize}
\item  \verb`FlexLexer (C++ only)` :Cxx
\item  \verb`YY_BUFFER_STATE` :Multiple Input Buffers
\item  \verb`YY_EXTRA_TYPE (reentrant only)` :Extra Data
\item  \verb`yy_size_t` :Multiple Input Buffers
\item  \verb`yyFlexLexer (C++ only)` :Cxx
\item  \verb`YYLTYPE` :Bison Bridge
\item  \verb`yyscan_t (reentrant only)` :About yyscan\_{}t
\item  \verb`YYSTYPE` :Bison Bridge
\end{itemize}

\section{Index of Hooks}


This is an index of "hooks" that the user may define. These hooks typically  correspond
to specific locations in the generated scanner, and may be used to insert arbitrary code.
\begin{itemize}
\item YY\_{}BREAK:Misc Macros
\item YY\_{}USER\_{}ACTION:Misc Macros
\item YY\_{}USER\_{}INIT:Misc Macros
\end{itemize}

\section{Index of Scanner Options}

\begin{itemize}
\item -+:Code-Level And API Options
\item —7bit:Options Affecting Scanner Behavior
\item —8bit:Options Affecting Scanner Behavior
\item —align:Options for Scanner Speed and Size
\item —always-interactive:Options Affecting Scanner Behavior
\item —array:Code-Level And API Options
\item —backup:Debugging Options
\item —batch:Options Affecting Scanner Behavior
\item —bison-bridge:Code-Level And API Options
\item —bison-locations:Code-Level And API Options
\item —c++:Code-Level And API Options
\item —case-insensitive:Options Affecting Scanner Behavior
\item —debug:Debugging Options
\item —default:Options Affecting Scanner Behavior
\item —ecs:Options for Scanner Speed and Size
\item —fast:Options for Scanner Speed and Size
\item —full:Options for Scanner Speed and Size
\item —header-file:Options for Specifying Filenames
\item —help:Miscellaneous Options
\item —interactive:Options Affecting Scanner Behavior
\item —lex-compat:Options Affecting Scanner Behavior
\item —main:Code-Level And API Options
\item —meta-ecs:Options for Scanner Speed and Size
\item —never-interactive:Options Affecting Scanner Behavior
\item —nodefault:Debugging Options
\item —noline:Code-Level And API Options
\item —nounistd:Code-Level And API Options
\item —nowarn:Debugging Options
\item —option-ansi-definitions:Code-Level And API Options
\item —option-ansi-prototypes:Code-Level And API Options
\item —outfile:Options for Specifying Filenames
\item —perf-report:Debugging Options
\item —pointer:Code-Level And API Options
\item —posix:Options Affecting Scanner Behavior
\item —prefix:Code-Level And API Options
\item —read:Options for Scanner Speed and Size
\item —reentrant:Code-Level And API Options
\item —skel:Options for Specifying Filenames
\item —stack:Options Affecting Scanner Behavior
\item —stdinit:Options Affecting Scanner Behavior
\item —stdout:Options for Specifying Filenames
\item —tables-file:Options for Specifying Filenames
\item —tables-verify:Options for Specifying Filenames
\item —trace:Debugging Options
\item —verbose:Debugging Options
\item —version:Miscellaneous Options
\item —warn:Debugging Options
\item —yyclass:Code-Level And API Options
\item —yylineno:Options Affecting Scanner Behavior
\item —yywrap:Options Affecting Scanner Behavior
\item -7:Options Affecting Scanner Behavior
\item -8:Options Affecting Scanner Behavior
\item -b:Debugging Options
\item -B:Options Affecting Scanner Behavior
\item -c:Miscellaneous Options
\item -C:Options for Scanner Speed and Size
\item -Ca:Options for Scanner Speed and Size
\item -Ce:Options for Scanner Speed and Size
\item -CF:Options for Scanner Speed and Size
\item -Cf:Options for Scanner Speed and Size
\item -Cm:Options for Scanner Speed and Size
\item -Cr:Options for Scanner Speed and Size
\item -d:Debugging Options
\item -F:Options for Scanner Speed and Size
\item -f:Options for Scanner Speed and Size
\item -h:Miscellaneous Options
\item -I:Options Affecting Scanner Behavior
\item -i:Options Affecting Scanner Behavior
\item -L:Code-Level And API Options
\item -l:Options Affecting Scanner Behavior
\item -n:Miscellaneous Options
\item -o:Options for Specifying Filenames
\item -p:Debugging Options
\item -P:Code-Level And API Options
\item -R:Code-Level And API Options
\item -s:Debugging Options
\item -T:Debugging Options
\item -t:Options for Specifying Filenames
\item -V:Miscellaneous Options
\item -v:Debugging Options
\item -w:Debugging Options
\item -X:Options Affecting Scanner Behavior
\item 7bit:Options Affecting Scanner Behavior
\item 8bit:Options Affecting Scanner Behavior
\item align:Options for Scanner Speed and Size
\item always-interactive:Options Affecting Scanner Behavior
\item ansi-definitions:Code-Level And API Options
\item ansi-prototypes:Code-Level And API Options
\item array:Code-Level And API Options
\item backup:Debugging Options
\item batch:Options Affecting Scanner Behavior
\item bison-bridge:Code-Level And API Options
\item bison-locations:Code-Level And API Options
\item c++:Code-Level And API Options
\item case-insensitive:Options Affecting Scanner Behavior
\item debug:Debugging Options
\item default:Options Affecting Scanner Behavior
\item ecs:Options for Scanner Speed and Size
\item fast:Options for Scanner Speed and Size
\item full:Options for Scanner Speed and Size
\item header-file:Options for Specifying Filenames
\item interactive:Options Affecting Scanner Behavior
\item lex-compat:Options Affecting Scanner Behavior
\item main:Code-Level And API Options
\item meta-ecs:Options for Scanner Speed and Size
\item nodefault:Debugging Options
\item noline:Code-Level And API Options
\item nounistd:Code-Level And API Options
\item nowarn:Debugging Options
\item noyyalloc:Overriding The Default Memory Management
\item outfile:Options for Specifying Filenames
\item perf-report:Debugging Options
\item pointer:Code-Level And API Options
\item posix:Options Affecting Scanner Behavior
\item prefix:Code-Level And API Options
\item read:Options for Scanner Speed and Size
\item reentrant:Code-Level And API Options
\item stack:Options Affecting Scanner Behavior
\item stdinit:Options Affecting Scanner Behavior
\item stdout:Options for Specifying Filenames
\item tables-file:Options for Specifying Filenames
\item tables-verify:Options for Specifying Filenames
\item trace:Debugging Options
\item verbose:Debugging Options
\item warn:Debugging Options
\item yyclass:Code-Level And API Options
\item yylineno:Options Affecting Scanner Behavior
\item yywrap:Options Affecting Scanner Behavior
\end{itemize}

\end{document}
